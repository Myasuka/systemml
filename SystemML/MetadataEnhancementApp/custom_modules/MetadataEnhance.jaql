
addClassPath("lib/metaDataParse.jar");
eval = javaudf("com.ibm.systemML.dataTransformation.metaDataParse");


// --------------------------------------------------------------------------------
// Read the input data in delimited format
// --------------------------------------------------------------------------------

inputData = fn(input, metadataMem, inputDelimiter) (

if (metadataMem == [])
(
   inputArray = if (isnull(inputDelimiter))
		  (
			read (del(location=input) )
		  )
		  else
		  (
			read (del(location=input, delimiter=inputDelimiter) )
		  ),
   numCols = inputArray[0] -> count(),
   attributeNames = range(1, numCols) -> transform serialize($),
   inputArray -> transform arrayToRecord(attributeNames, $)
)
else
(
   schemaString = metadataMem
      -> transform $.attributeName + ":" + $.attributeType
      -> strJoin(","),

   // schema of the input
   inputSchema = "schema {" + schemaString + "}",

   if (isnull(inputDelimiter))
		  (
			read (del(location=input, 
				schema = eval(inputSchema) ) )
		  )
		  else
		  (
			read (del(location=input, delimiter=inputDelimiter,
				schema = eval(inputSchema) ) )
		  )
)
);


//
// Generate metadata json file
// We do some pre-aggregation to avoid Java Heap size problem for distinct()
// in group by.
//

genMetadata = fn (inputData)
(
   inputData
      -> expand (fields($))
      -> group by d = $ 
            into { attributeName: d[0] 
                  ,num: count($) 
              }
      -> group by d = $.attributeName 
            into { attributeName: d
                  ,attributeCount: sum($[*].num) 
                 }
      -> group 
            into (cA = count($),
   	       $ -> transform each a {a.*, 
                                        countAttributes: cA
                                        }
                 ) 
      -> expand $
         // set attribute kind based on some heuristics
      -> enumerate()
      -> transform {"attributeColumnId":$[0] + 1, $[1].*}
);


// --------------------------------------------------------------------------------
// Insert a heuristically derived value for any missing (null) attributeKind fields
// --------------------------------------------------------------------------------

metaEnhance = fn(inputData, metadataMem, outputMetadata) (

kindHeuristic = genMetadata (inputData),

join orig in metadataMem, preserve new in kindHeuristic 
   where orig.attributeName == new.attributeName
   into {
      new.attributeName,
      "attributeColumnId":(if (isnull(orig.attributeColumnId)) new.attributeColumnId else orig.attributeColumnId),
      "attributeKind":(if (isnull(orig.attributeKind)) "N/A" else orig.attributeKind),
      "attributeType":(if (isnull(orig.attributeType)) "N/A" else orig.attributeType),
      "attributeDistinctCount": (if (isnull(orig.attributeDistinctCount)) "N/A" else orig.attributeDistinctCount)
   }
   -> sort by [$.attributeColumnId]
   -> write(jsonText(outputMetadata))

);

