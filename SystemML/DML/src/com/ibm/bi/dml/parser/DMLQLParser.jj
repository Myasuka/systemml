// Parser for DML QL files

options { 
	STATIC = false;
	// JDK_VERSION = "5.0";
 	DEBUG_PARSER = false;
 	DEBUG_TOKEN_MANAGER = false;
 	UNICODE_INPUT = true;
 	//COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(DMLQLParser)

package com.ibm.bi.dml.parser;

import java.io.*;
import java.util.*; 
import java.util.regex.*;
import com.ibm.bi.dml.parser.Expression.DataType;
import com.ibm.bi.dml.parser.Expression.ValueType;
import com.ibm.bi.dml.parser.Expression.FormatType;
import com.ibm.bi.dml.parser.Expression.BinaryOp;
import com.ibm.bi.dml.utils.LanguageException;
import java.util.ArrayList;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;



/**
 * Main entry point for the DML QL file parser.
 * 
 * NOTE: This class is GENERATED from DMLQLParser.jj!!!
 */
public class DMLQLParser extends DMLQLParserBase{

	protected static final Log LOG = LogFactory.getLog(DMLQLParser.class.getName());

	/** stores the listing of command-line arguments, which are indexed from 1 and being with '$' --  $1, $2, etc. **/
 	private HashMap<String,String> commandArgs; 

	/** stores list of paths to DML packages (directories to look for modules) **/
 	private ArrayList<String> dmlPathSet;
	private boolean alreadySeen = false;

	/** stores the mapping of absolute path to namespace program **/
	/** if the module in the absolute path has been processed, then use this program  **/
	static private HashMap<String, DMLProgram> allNamespacesByAbsolutePath = new HashMap<String, DMLProgram>();

 	/** Convenience constructor for reading from a string. */
 	public DMLQLParser(String s)throws IOException, ParseException {
  		this(new StringReader(s));
 	}
 
	/** Convenience constructor for reading from a string. */
	public DMLQLParser(String s2, String encoding, HashMap<String,String> commandArgs)throws IOException, ParseException {
	
		this(new BufferedReader(new StringReader(s2)));
		setFileEncoding(encoding);
	    setCommandArgs(commandArgs);
	        
	  	// initialize pathset to current working directory
	  	dmlPathSet = new ArrayList<String>();
	    dmlPathSet.add(".");
	    alreadySeen = false;
	}

 	public DMLQLParser(File f, String encoding, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(new BufferedReader(new InputStreamReader(new FileInputStream(f), encoding)));         
		setFileEncoding(encoding);
		setCommandArgs(commandArgs);
		      
		// initialize pathset to current working directory
		dmlPathSet = new ArrayList<String>();
		dmlPathSet.add(".");

		if (DMLQLParser.allNamespacesByAbsolutePath.get(f.getAbsolutePath()) != null)
			alreadySeen = true;
		else {
			alreadySeen = false;
			DMLQLParser.allNamespacesByAbsolutePath.put(f.getAbsolutePath(), new DMLProgram());
		}       
	}

	private void setCommandArgs(HashMap<String,String> ca){
		commandArgs = ca;
	}

	private String printErrorLocation(int line, int col){
		return "ERROR: line " + line + ", col " + col + " -- "; 
	}

	private String printWarningLocation(int line, int col){
		return "WARNING: line " + line + ", col " + col + " -- "; 
	}	  

 	private void setDmlPathSet(ArrayList<String> passed){
  		dmlPathSet = passed;
 	}
    
	public DMLQLParser(File f, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(f, DEFAULT_ENCODING, commandArgs);
	}

	public DMLQLParser(String s2, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(s2, DEFAULT_ENCODING, commandArgs);
	}

	public static final String LANG_JAVA = "Java";

	private String getTokenInfo(Token t){
		if (t == null)
			return ""; 
		else
			return "(" + t.toString() + " in line " + t.beginLine + ", column " + t.beginColumn + ")";
	}
	
}  // end class DMLQLParser

PARSER_END(DMLQLParser)

///////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN LEXER
///////////////////////////////////////////////////////////////////////////////////////////////////

SKIP :
{
	" "
	| "\t"
	| "\n"
	| "\r"
}


// COMMENTS
// JavaCC's lexer handles comments (and other ambiguous tokens) differently
// from normal tokens.

MORE :
{
	"#" : IN_SINGLE_LINE_COMMENT
}  

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT : (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
	< ~[] >
}


// Multi-line comments; copied from 

// http://www.idevelopment.info/data/Programming/java/JavaCC/The_JavaCC_FAQ.htm#more
// When a /* is seen in the DEFAULT state, skip it and switch to the IN_COMMENT state
MORE : { "/*": IN_COMMENT } 
     
// When any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > MORE : { <  ~[] > } 

// When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : { "*/": DEFAULT } 



// Block comments
//SPECIAL_TOKEN : /* COMMENTS */
//{
// <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
//}


TOKEN :
{
	//////////////////////////////////////////////////////////////////////
	// RESERVED KEYWORDS -- core to DML, common to R language
	<IF  		: "if">
	| <ELSE  	: "else">
	| <WHILE  	: "while">
	| <FOR  	: "for">
	| <TRUE  	: "true">
	| <FALSE  	: "false">
	| <NULL  	: "null">
	| <FUNCTION : "function">

	// RESERVED KEYWORDS -- core to DML, not in R
	| <RETURN 				: "return" >
	| <EXTERNALFUNCTION 	: "externalFunction" >
	| <IMPLEMENTED_IN 		: "implemented in" >
	| <PARFOR 		: "parfor">
	| <RAND     	: "Rand">
	| <PRINT 		: "print">
	| <READMATRIX 	: "read">
	| <WRITEMATRIX 	: "write">
	| <READMM		: "readMM" >
	| <WRITEMM		: "writeMM" >
	| <READ_MATRIX	: "read.matrix" >
	| <WRITE_MATRIX	: "write.matrix" >


	// RESERVED KEYWORDS -- required for meta-learning
 	| <BUILD_ENSEMBLE	: "build ensemble" >
	| <USE_ENSEMBLE 	: "use ensemble" >
	| <CROSSVAL 		: "crossval">

	// RESERVED KEYWORDS -- required to support import / packages -- NOT common to R
	| <IMPORT 		: "import"> 
	| <DMLPATH 		: "dml-path">  
	| <AS  			: "as">

	// RESERVED KEYWORDS -- could be eliminated, may cause issue with lookahead
	| <SEQ 		: "seq">  

	//|<NEXT  	: "next">
	//|<BREAK  	: "break">

	//| <INF  	: "Inf">
	//| <NAN  	: "NaN">
	//| <NA  	: "NA">

 	
	/////////////////////////////////////////////////////////
	// Operators
	| <PLUS  		: "+">
	| <MINUS  		: "-">
	| <MULT  		: "*">
	| <DIV  		: "/">
	| <MATRIXMULT 	: "%*%">
	| <POWER  		: "^">
	| <LESSEQUAL  	: "<=">
	| <LESS 		: "<">
	| <GREATEREQUAL : ">=">
	| <GREATER  	: ">">
	| <EQUAL  		: "==">
	| <NOTEQUAL  	: "!=">
	| <ASSIGN  		: "=">
	| <LEFTASSIGN  	: "<-">
	| <CONDITIONALAND  	: "&&">
	| <LOGICALAND  		: "&">
	| <CONDITIONALOR  	: "||">
	| <LOGICALOR  		: "|">
	| <NOT 				: "!">
 
	////////////////////////////////////////////////////////
	// DELIMITERS
 	|  <SEMICOLON  		: ";">
 	|  <COLON  			: ":" >
 	|  <LEFTPAREN   	: "(">
 	|  <RIGHTPAREN  	: ")">
 	|  <COMMA       	: ",">
 	|  <LEFTCURLYPAREN  : "{">
 	|  <RIGHTCURLYPAREN : "}">
 	|  <LEFTSQUARE  	: "[">
 	|  <RIGHTSQUARE  	: "]">
  
 	/////////////////////////////////////////////////////////
 	// LITERALS
 
 	// The name of an optree or an existing annotation type.
 	| <ID : ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","0"-"9","_"])* >
 	| <DOLLAR_ID : "$"(["a"-"z","A"-"Z","0"-"9","_"])* >

 	// A number with no decimal point -- minus sign is a separate token
 	| <INTEGER : (["0"-"9"])+>
 
 	// A number with decimal point -- minus sign is a separate token
 	| <DOUBLE : (["0"-"9"])* "." (["0"-"9"])+>
 
	// A double-quoted string literal (Based on JavaCC.jj)
 	| <DBLQUOTE_STRING_LITERAL :
  	"\""
     	(   (~["\"","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )*
       "\""
    > 

 	// SQL-style string literal in single quotes
 	| <SQL_STRING_LITERAL :
  	"'"
       (   (~["'","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )*
       "'"
    > 
} // end TOKEN

///////////////////////////////////////////////////////////////////////////////////////////////////
// END LEXER
///////////////////////////////////////////////////////////////////////////////////////////////////


DMLProgram __inputInternal() :
{
	DMLProgram dmlp = new DMLProgram();
	Statement current = null;
	Token reserved = null;
}
{
	(
		(
			LOOKAHEAD(PathStatement())					current = PathStatement() 
			| LOOKAHEAD(ImportStatement())				current = ImportStatement()
			| LOOKAHEAD(RandStatement()) 	  			current = RandStatement()
			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
			| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
			| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
			| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
			| LOOKAHEAD(ForStatement())					current = ForStatement()
			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
			| LOOKAHEAD(IfStatement())					current = IfStatement()
			|  LOOKAHEAD(CVStatement())					current = CVStatement()
			| LOOKAHEAD(ELStatement())					current = ELStatement()
			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
		)
		{
			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
				sb = new WhileStatementBlock();
			}
			else if (current instanceof ParForStatement) {
				sb = new ParForStatementBlock();
			}
			else if (current instanceof ForStatement) {
				sb = new ForStatementBlock();
			}
			else if (current instanceof IfStatement){
				sb = new IfStatementBlock(); 
			} 
			else if (current instanceof CVStatement) {
			  	LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
			  	LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
				LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
			else if (current instanceof FunctionStatement) {
				sb = new FunctionStatementBlock();
			}
			else {
				sb = new StatementBlock();
			}
			sb.addStatement(current);
			
			// handle import statements
			if (current instanceof ImportStatement) {

				// if the path verifies, parse the file to create a DMLProgram
				ImportStatement importStmt = (ImportStatement) sb.getStatement(0);
				if (importStmt.verify(dmlPathSet)) {

					try {
						DMLProgram importedProg = null;
						File moduleFile = new File(importStmt.getCompletePath());
						System.out.println("INFO: line " + importStmt.getBeginLine() + ", column " + importStmt.getBeginColumn() + " -- importing module file: " + ((ImportStatement)current).getCompletePath());

						//if (DMLQLParser.allNamespacesByAbsolutePath.get(((ImportStatement)current).getAbsolutePath()) == null){  
						DMLQLParser parser = new DMLQLParser(moduleFile,null);
						if (parser.alreadySeen)
							importedProg = DMLQLParser.allNamespacesByAbsolutePath.get(((ImportStatement)current).getAbsolutePath());
						else {
							importedProg = parser.parse();
							DMLQLParser.allNamespacesByAbsolutePath.put(((ImportStatement)current).getAbsolutePath(), importedProg);       
						}
     
						// set the key to be the name of the module or the alias      
						String namespaceKey = (importStmt.getAlias() == null) ? importStmt.getModuleName() : importStmt.getAlias();

						// IF (alias is defined OR no filter placed on functions to import) THEN
						//  1) attempt to create new namespace for imported DML module file if not already defined
						//  2) attempt to add functions to existing namespace
						if (importStmt.getAlias() != null || ( !importStmt.getImportAll() && importStmt.getImportVarList().size() == 0)) {

							if (!dmlp.getNamespaces().containsKey(namespaceKey))
								dmlp.getNamespaces().put(namespaceKey,importedProg);
	  
							else {
								// attempt to import the new functions in the importedProgram (DML file specified in import statement) into the existing namespace
								for (String fname : importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).keySet()){
									if (dmlp.getFunctionStatementBlock(namespaceKey,fname) != null)									{  
										LOG.error(importStmt.printErrorLocation() + "function " + fname + " already defined in namespace " + namespaceKey);
										throw new ParseException(importStmt.printErrorLocation() + "function " + fname + " already defined in namespace " + namespaceKey);
									}
									else 
	          							dmlp.getFunctionStatementBlocks(namespaceKey).put(fname, importedProg.getFunctionStatementBlock(DMLProgram.DEFAULT_NAMESPACE, fname));   
	        					}
	       					}
						}


	        			// import all functions into the current "null" namespace
						if(importStmt.getImportAll()){
	
							for (String fname : importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).keySet()){
				
				        		if (dmlp.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(fname)){				        			LOG.error(importStmt.printErrorLocation() + "function " + fname + " is already defined in current namespace ");
									throw new ParseException(importStmt.printErrorLocation() + "function " + fname + " is already defined in current namespace ");
								}	
								String currName = (importStmt.getAlias() == null) ? null : importStmt.getAlias();
								dmlp.getFunctionStatementBlocks(currName).put(fname,importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).get(fname));
							} 
						}
      
						// import named functions into current namespace. Named functions must NOT exist in current namespace ("null" namespace).
						else if (importStmt.getImportVarList().size() > 0){
							for (String fname : importStmt.getImportVarList()) {
				
								if (dmlp.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(fname)){
									LOG.error(importStmt.printErrorLocation() + "function " + fname + " is already defined in current namespace ");
									throw new ParseException(importStmt.printErrorLocation() + "function " + fname + " is already defined in current namespace ");
								}
								if (!importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(fname)){									LOG.error(importStmt.printErrorLocation() + "function " + fname + " not defined in module path " + importStmt.getModulePath());								  
									throw new ParseException(importStmt.printErrorLocation() + "function " + fname + " not defined in module path " + importStmt.getModulePath());
								}
								String currName = (importStmt.getAlias() == null) ? null : importStmt.getAlias();
								dmlp.getFunctionStatementBlocks(currName).put(fname,importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).get(fname));
							}
						}     
					}
					catch(Exception e){
					  	LOG.error(e.getMessage());
						throw new ParseException(e.getMessage());
					}
				} // if (importStmt.verify(dmlPathSet))
    
    			else {
    			    LOG.error(importStmt.printErrorLocation() + "failed to import " + importStmt.toString());
     				throw new ParseException(importStmt.printErrorLocation() + "failed to import " + importStmt.toString());
    			}

    			// add import statement to DML program
    			dmlp.addStatementBlock(sb);

			} // if (current instanceof ImportStatement)

			// handle function declarations
			else if (sb instanceof FunctionStatementBlock) {
				FunctionStatement first  = (FunctionStatement)((FunctionStatementBlock)sb)._statements.get(0);
				try {

					// check if the function is defined in the current namespace
					if (dmlp.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(first.getName())){					    LOG.error(first.printErrorLocation() + "function " + first.getName() + " already defined in current namespace ");
						throw new LanguageException(first.printErrorLocation() + "function " + first.getName() + " already defined in current namespace ");
					}
					dmlp.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).put(first.getName(), (FunctionStatementBlock)sb);
				} catch (LanguageException e) {
				  	LOG.error(e.getMessage());
					throw new ParseException(e.getMessage());
				}
			} 
			else {
				dmlp.addStatementBlock(sb);
			}
		}
 	)* <EOF>

 	{
  		dmlp.mergeStatementBlocks();
  		return dmlp;
 	}
}

PathStatement PathStatement():
{
	// track start / end token positions
	Token tStart = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	
	Token t1 = null;
	PathStatement pstmt = new PathStatement();
}
{
	tStart = <DMLPATH> t1 = <DBLQUOTE_STRING_LITERAL>
	{
		String dequotedString = dequoteStr('\"',t1.image);
		pstmt.addPackagePaths(dequotedString);
		dmlPathSet.addAll(pstmt.getPackagePaths());
	}
	[<SEMICOLON>]

	{
		// track position for start token tStart, end token t1
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = t1.endLine;
		ecp = t1.endColumn;
		pstmt.setAllPositions(blp, bcp, elp, ecp);

		return pstmt;
	}
}

ImportStatement ImportStatement() :
{
	// track start / end token positions
	Token tStart = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;

	Token t1 = null, t2 = null, t3 = null, t4 = null;
	ImportStatement importStmt = new ImportStatement();

	// directory structure of DML package containing module being imported
	// last entry is the name of the module.
	ArrayList<String> modulePathPieces = new ArrayList<String>();
}
{
	tStart = <IMPORT> t1 = <ID> { modulePathPieces.add(t1.image);}
	(<COLON><COLON> t1 = <ID> {modulePathPieces.add(t1.image);})*
 
	[<LEFTPAREN>
		[ t2 = <MULT>{ importStmt.setImportAll(true);} | t3 = <ID> {importStmt.addVar(t3.image);}
			(<COMMA> t3 = <ID>{importStmt.addVar(t3.image);} )*]
	<RIGHTPAREN>]

	[<AS> t4 = <ID> {importStmt.setAlias(t4.image);}] [<SEMICOLON>]

	{ 
		// track position for start / end token tStart
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;

		if (t4 != null){
			elp = t4.endLine;
			ecp = t4.endColumn;
		}
		else if (t3 != null){
			elp = t3.endLine;
			ecp = t3.endColumn;
		}
		else if (t2 != null){
			elp = t2.endLine;
			ecp = t2.endColumn;
		}
		else {
			elp = t1.endLine;
			ecp = t1.endColumn;
		}

		importStmt.setAllPositions(blp, bcp, elp, ecp);

		importStmt.setModulePathAndName(modulePathPieces);
		return importStmt;
	}
}

FunctionStatement FunctionStatement() :
{
	Vector <DataIdentifier> functionInputs = new Vector<DataIdentifier>(), functionOutputs = new Vector<DataIdentifier>() ;
	FunctionStatement fstmt = new FunctionStatement();
	Token t = null;
	Statement current = null;

	// track start / end token positions
	Token tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	t = <ID> <ASSIGN> <FUNCTION> functionInputs = ReadTypedArgList()
		(<RETURN> functionOutputs = ReadTypedArgList())?
	<LEFTCURLYPAREN>
	(
		(

  			LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
  			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement()
  			| LOOKAHEAD(MultiAssignmentStatement()) 		current = MultiAssignmentStatement()
  			| LOOKAHEAD(InputStatement()) 				current = InputStatement()
  			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
  			| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
   			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
			| LOOKAHEAD(ForStatement())					current = ForStatement()
			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
			| LOOKAHEAD(IfStatement())					current = IfStatement()
			| LOOKAHEAD(CVStatement())					current = CVStatement()
			| LOOKAHEAD(ELStatement())					current = ELStatement()
			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
		)

		{
   			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
				sb = new WhileStatementBlock();
			}
			else if (current instanceof ParForStatement) {
				sb = new ParForStatementBlock();
			}
			else if (current instanceof ForStatement) {
				sb = new ForStatementBlock();
			}
			else if (current instanceof IfStatement){
				sb = new IfStatementBlock(); 
			}
			else if (current instanceof CVStatement) {
			  	LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
			    LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
				LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
			else if (current instanceof FunctionStatement) {
			  	LOG.error(current.printErrorLocation() + "Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + "Nested function definitions are not supported ");
			}
			else if (current instanceof ExternalFunctionStatement) {
				LOG.error(current.printErrorLocation() + "Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + "Nested function definitions are not supported ");
			}	
		   
			else {
				sb = new StatementBlock();
			}
			sb.addStatement(current);
			fstmt.addStatementBlock(sb);
		}
 	)*
 	{
  		fstmt.mergeStatementBlocks(); 
 	}
	tEnd = <RIGHTCURLYPAREN>
	
	{
		fstmt._inputParams = functionInputs ;
		fstmt._outputParams = functionOutputs ;
		fstmt.setName(t.image);

		// track position for start / end token tStart
		fstmt.setAllPositions(t.beginLine, t.beginColumn, tEnd.beginLine, tEnd.beginColumn);

		return fstmt;
	}
}

ExternalFunctionStatement ExternalFunctionStatement() :
{
	Vector <DataIdentifier> functionInputs = null, functionOutputs = null ;
	ExternalFunctionStatement fstmt = new ExternalFunctionStatement();
	Token t = null;
	Statement current = null;
	HashMap<String,String> map = null;

	// track start / end token positions
	Token tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	
}
{
	t = <ID> <ASSIGN> <EXTERNALFUNCTION> functionInputs = ReadTypedArgList()
	<RETURN> functionOutputs = ReadTypedArgList()
	tEnd = <IMPLEMENTED_IN> map = ReadGenericParamList()[ tEnd = <SEMICOLON>]
 
	{
		fstmt.setOtherParams(map);
		fstmt._inputParams = functionInputs ;
		fstmt._outputParams = functionOutputs ;
		fstmt.setName(t.image);

		// track position for start / end token tStart
		blp = t.beginLine;
		bcp = t.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		fstmt.setAllPositions(blp, bcp, elp, ecp);

     	return fstmt;
  	}
}


HashMap <String,String > ReadGenericParamList() :
{
	HashMap<String,String > map = new HashMap<String,String >() ;
	Token t1 = null, t2 = null;
	IntIdentifier intid = null;
	DoubleIdentifier doubleid = null;
	BooleanIdentifier boolid = null;

	// track start / end token positions
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
		
}
{
	tStart = <LEFTPAREN> t1 = <ID> <ASSIGN>
	(
		LOOKAHEAD(2) intid = IntConstant() { map.put(t1.image, intid.toString()); }
		| doubleid = DoubleConstant() { map.put(t1.image, doubleid.toString());   }
		| boolid = BooleanConstant()  { map.put(t1.image, boolid.toString());     }
		| t2 = <SQL_STRING_LITERAL>   { map.put(t1.image, dequoteStr('\'',t2.image));    }
		| t2 = <DBLQUOTE_STRING_LITERAL> { map.put(t1.image, dequoteStr('\"',t2.image)); }
	)
	
	(
		< COMMA > t1 = < ID > <ASSIGN>

		(
			LOOKAHEAD(2) intid = IntConstant() { map.put( t1.image, intid.toString());}
			| doubleid = DoubleConstant()    { map.put( t1.image, doubleid.toString());}
			| boolid = BooleanConstant()     { map.put( t1.image, boolid.toString());} 
			| t2 = <SQL_STRING_LITERAL>      { map.put( t1.image, dequoteStr('\'',t2.image));}
			| t2 = <DBLQUOTE_STRING_LITERAL> { map.put( t1.image, dequoteStr('\"',t2.image));}
		)
	)*
	tEnd = <RIGHTPAREN>
	
	{
		// track position for start / end token tStart
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		//fstmt.setAllPositions(blp, bcp, elp, ecp);

		return map ;
	}
}


// NOTE: DML only supports default values for scalar datatype
Vector<DataIdentifier> ReadTypedArgList() :
{
	Vector<DataIdentifier> params = new Vector<DataIdentifier>() ;
	DataIdentifier d1=null, d2=null ;
	Token t1 = null, t2 = null, t3 = null;
	String valueType = null;
	String dataType = null;
	IntIdentifier intid = null;
	DoubleIdentifier doubleid = null;
	BooleanIdentifier boolid = null;  
} 
{
	<LEFTPAREN> t1 =<ID> [<LEFTSQUARE> t2 = <ID> <RIGHTSQUARE>] d1 = Identifier() 

	// For scalar inputs, support assigmnent of default value for function parameters 
	(
		<ASSIGN> intid = IntConstant() 		  { d1.setDefaultValue(intid.toString());}
				| doubleid = DoubleConstant() { d1.setDefaultValue(doubleid.toString()); }
      			| boolid = BooleanConstant()  { d1.setDefaultValue(boolid.toString()); }
      			| t3 = <SQL_STRING_LITERAL>   { d1.setDefaultValue(dequoteStr('\'',t3.image)); }
      			| t3 = <DBLQUOTE_STRING_LITERAL> { d1.setDefaultValue(dequoteStr('\"',t3.image)); }
	)?

	{
		if (t1.image.equalsIgnoreCase("matrix")){
			if (t2 == null){
			    LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " cannot process argument " + params.size() + 1 + " for UDF " + t1.image);	  
     			LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " Valuetype (int, double, boolean, String) must be defined for Matrix datatype -- e.g., Matrix(Double) ");
				System.out.println(printErrorLocation(t1.beginLine, t1.beginColumn) + " cannot process argument " + params.size() + 1 + " for UDF " + t1.image);	  
     			throw new ParseException(printErrorLocation(t1.beginLine, t1.beginColumn) + " Valuetype (int, double, boolean, String) must be defined for Matrix datatype -- e.g., Matrix(Double) ");
    		}
    		else {
     			dataType = "matrix";
     			valueType = t2.image;
    		}
       	}
     	else if (t1.image.equalsIgnoreCase("object")){
    		dataType = "object";
    		valueType = "object";
     	}
		else {
			dataType = "scalar";
			valueType = t1.image;
        }

		try {
		  	d1.setTypeInfo(valueType, dataType);      
       		params.add(d1);
       } catch (ParseException e) {
         	LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " function parameter has unknown value type");
			throw new ParseException(printErrorLocation(t1.beginLine, t1.beginColumn) + " function parameter has unknown value type");
       }
	}

	(
		<COMMA>  t1 = <ID> [<LEFTSQUARE> t2 = <ID> <RIGHTSQUARE>]  d2 = Identifier()

  		(
			<ASSIGN> intid = IntConstant()     { d2.setDefaultValue(intid.toString());}
	    		| doubleid = DoubleConstant() { d2.setDefaultValue(doubleid.toString()); }
	    		| boolid = BooleanConstant()  { d2.setDefaultValue(boolid.toString()); }
	    		| t3 = <SQL_STRING_LITERAL>   { d2.setDefaultValue(dequoteStr('\'',t3.image)); }
	    		| t3 = <DBLQUOTE_STRING_LITERAL> {d2.setDefaultValue(dequoteStr('\"',t3.image));}
	  	)?

		{
			if (t1.image.equalsIgnoreCase("matrix")){
				if (t2 == null){
					LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " cannot process argument " + params.size() + 1 + " for UDF " + t1.image);
	     			LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " Valuetype (int, double, boolean, String) must be defined for Matrix datatype -- e.g., Matrix(Double) ");
				  	System.out.println(printErrorLocation(t1.beginLine, t1.beginColumn) + " cannot process argument " + params.size() + 1 + " for UDF " + t1.image);
	     			throw new ParseException(printErrorLocation(t1.beginLine, t1.beginColumn) + " Valuetype (int, double, boolean, String) must be defined for Matrix datatype -- e.g., Matrix(Double) ");
	    		}
	    		else {
	     			dataType = "matrix";
	    	 		valueType = t2.image;
	    		}
	     	}
			else if (t1.image.equalsIgnoreCase("object")){
	    		dataType = "object";
	    		valueType = "object";
	   		}
	     	else {
	        	dataType = "scalar";
	         	valueType = t1.image;
	   		}  
	     	d2.setTypeInfo(valueType, dataType);        
	       	params.add(d2);
	  	}
 	)*
	<RIGHTPAREN>
  
	{ return params; }
}

ArrayList<String> ReadList() :
{
	ArrayList<String> params = new ArrayList<String>() ;
	Token t1 = null, t2=null ;
} 
{
	<LEFTPAREN> 
		t1 = <ID> {params.add(t1.image);} (<COMMA> t2 = <ID> {params.add(t2.image);})*
	<RIGHTPAREN> 
	{return params;}
}


ArrayList<ArrayList<Expression>> ReadIndexList() :
{
	ArrayList<ArrayList<Expression>> targetListList = new ArrayList<ArrayList<Expression>>();
	ArrayList<Expression> targetList = null;
	Expression target = null;

}
{ 
	<LEFTSQUARE>
	(
		LOOKAHEAD(ColonDelimitedExpression())
     	targetList = ColonDelimitedExpression() {targetListList.add(targetList);}
     	| target = Expression() {targetList = new ArrayList<Expression>(); targetList.add(target); targetListList.add(targetList); } 	
	)?
	{
	  	// CASE: no indexing dimensions given
		if (targetList == null){
			targetList = new ArrayList<Expression>();
			targetList.add(null);
			targetList.add(null);
			targetListList.add(targetList);
		}
		targetList = null;
	}
    
	(
		<COMMA>
		(
			LOOKAHEAD( ColonDelimitedExpression())
			targetList = ColonDelimitedExpression() {targetListList.add(targetList);}
			|	target = Expression() { targetList = new ArrayList<Expression>(); targetList.add(target); targetListList.add(targetList);}
   		)?
   		{
   	  	
			// CASE: no indexing dimesnions given
			if (targetList == null)
			{
				targetList = new ArrayList<Expression>();
				targetList.add(null);
				targetList.add(null);
				targetListList.add(targetList);
			}
			targetList = null;

   		}
  	)* 
  	<RIGHTSQUARE> 

  	{return targetListList; }
}


ArrayList<Expression> ColonDelimitedExpression() :
{
	ArrayList<Expression> exprsList = new ArrayList<Expression>();
	Expression left = null, right = null;
	Token tStart = null;
}
{
 	[left = Expression()] tStart = <COLON> [right = Expression()] 
 	{
		if (left == null && right == null){
			LOG.error(printErrorLocation(tStart.beginLine, tStart.beginColumn) + " colon delimiter cannot be specified when no indexing expressions used");
			throw new ParseException(printErrorLocation(tStart.beginLine, tStart.beginColumn) + " colon delimiter cannot be specified when no indexing expressions used");
		}
  		exprsList.add(left);
  		exprsList.add(right); 
  		return exprsList;
	}
}

MultiAssignmentStatement MultiAssignmentStatement() :
{
	Expression source = null;
	ArrayList<ArrayList<Expression>> targetListList = null;
	Token tStart =  null, tEnd = null;
	int blp =0, bcp = 0, elp = 0, ecp = 0; 
}
{
	targetListList = ReadIndexList() tStart = <ASSIGN> source = Expression() [<SEMICOLON>] 
	{
		MultiAssignmentStatement retVal =  new MultiAssignmentStatement(targetListList, source, 0);

		// track position for statement
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = source.getEndLine();
		ecp = source.getEndColumn();
		retVal.setAllPositions(blp, bcp, elp, ecp);
		
   		return retVal;
	}
}

AssignmentStatement AssignmentStatement() :
{
	Expression source;
	DataIdentifier target;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	target = Identifier()
	{
		if (target.getName().startsWith("$"))		{		    LOG.error(target.printErrorLocation() + " cannot use variable assigned from command-line " + target.getName() + " on left-hand side of assignment statement");
			throw new ParseException(target.printErrorLocation() + " cannot use variable assigned from command-line " + target.getName() + " on left-hand side of assignment statement");
		}
	}
  		<ASSIGN> source = Expression() [<SEMICOLON>] 
	{
		AssignmentStatement retVal = new AssignmentStatement(target, source); 

		// track position for statement
		blp = target.getBeginLine();
		bcp = target.getBeginColumn();
		elp = source.getEndLine();
		ecp = source.getEndColumn();
		retVal.setAllPositions(blp, bcp, elp, ecp);

		return retVal;
	}
}


IfStatement IfStatement() :
{
	IfStatement is = new IfStatement();
	Statement current = null;
	ConditionalPredicate cp = null;

	// track start / end token positions
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	
}
{
	tStart = <IF> cp = ConditionalPredicate() { is.setConditionalPredicate(cp); }
 	<LEFTCURLYPAREN>
 	(
		(
			LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
			| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
			| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
			| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
			| LOOKAHEAD(ForStatement())					current = ForStatement()
			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
			| LOOKAHEAD(IfStatement())					current = IfStatement()
			| LOOKAHEAD(CVStatement())					current = CVStatement()
			| LOOKAHEAD(ELStatement())					current = ELStatement()
			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()

	   	)
		{
			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
	 			sb = new WhileStatementBlock();
			}
			else if (current instanceof IfStatement) {
				sb = new IfStatementBlock();
			}
			else if (current instanceof ParForStatement) {
				sb = new ParForStatementBlock();
			}
			else if (current instanceof ForStatement) {
				sb = new ForStatementBlock();
			}
			else if (current instanceof FunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " nested function definitions are not supported ");
			}
			else if (current instanceof ExternalFunctionStatement) {
			    LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}
			else if (current instanceof CVStatement) {
				LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
			  	LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
			    LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
			else {
				sb = new StatementBlock();
			}
			sb.addStatement(current);
			is.addStatementBlockIfBody(sb);
		}
	)*
 	tEnd = <RIGHTCURLYPAREN>

 	{
		is.mergeStatementBlocksIfBody();
 	}

 	(
		LOOKAHEAD(1) <ELSE>
  		<LEFTCURLYPAREN>
   		(
			(
				LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
   				| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
				| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
				| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
				| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
				| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
				| LOOKAHEAD(OutputStatement())				current = OutputStatement()
				| LOOKAHEAD(PrintStatement())				current = PrintStatement()
				| LOOKAHEAD(WhileStatement())				current = WhileStatement()
				| LOOKAHEAD(ForStatement())					current = ForStatement()
				| LOOKAHEAD(ParForStatement())				current = ParForStatement()
				| LOOKAHEAD(IfStatement())					current = IfStatement()
				| LOOKAHEAD(CVStatement())					current = CVStatement()
				| LOOKAHEAD(ELStatement())					current = ELStatement()
				| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
   
   			)
   			{
			    StatementBlock sb = null;
			    if (current instanceof WhileStatement) {
			    	sb = new WhileStatementBlock();
			    }
			    else if (current instanceof IfStatement) {
			    	sb = new IfStatementBlock();
			    }
			    else if (current instanceof ParForStatement) {
			    	sb = new ParForStatementBlock();
			    }
			    else if (current instanceof ForStatement) {
			    	sb = new ForStatementBlock();
			    }
				else if (current instanceof FunctionStatement) {
					LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
			    	throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			  	}
			  	else if (current instanceof ExternalFunctionStatement) {
					LOG.error(current.printErrorLocation()+ " Nested function definitions are not supported ");
			  		throw new ParseException(current.printErrorLocation()+ " Nested function definitions are not supported ");
			  	}
			  	
			    else if (current instanceof CVStatement) {
					LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
					throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
					//sb = new CVStatementBlock();
				}
				else if (current instanceof ELStatement) {
					LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
					throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
					//sb = new ELStatementBlock();
				}
				else if (current instanceof ELUseStatement) {
					LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
					throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
					//sb = new ELUseStatementBlock();
				}   
			    else {
			    	sb = new StatementBlock();
			    }
			    sb.addStatement(current);
			    is.addStatementBlockElseBody(sb);
			}
   		)*
 		tEnd = <RIGHTCURLYPAREN>
  		{
    		is.mergeStatementBlocksElseBody();
  		}
 	)?
 	{
		// track position for statement
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		is.setAllPositions(blp, bcp, elp, ecp);

		return is;
 	}
}


ForStatement ForStatement() :
{
	ForStatement fs = new ForStatement();
	Statement current = null;
	IterablePredicate ip = null;
	
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
 
	tStart = <FOR> ip = IterablePredicate() {fs.setPredicate(ip);}
	<LEFTCURLYPAREN>
	(
		(
			LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
   			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
   			| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
   			| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
   			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
   			| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
   			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
   			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
   			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
   			| LOOKAHEAD(ForStatement())					current = ForStatement()
   			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
   			| LOOKAHEAD(IfStatement())					current = IfStatement()
			| LOOKAHEAD(CVStatement())					current = CVStatement()
			| LOOKAHEAD(ELStatement())					current = ELStatement()
			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
 
		)
		{
			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
				sb = new WhileStatementBlock();
			}
			else if (current instanceof IfStatement) {
				sb = new IfStatementBlock();
			}
			else if (current instanceof ParForStatement) {
				sb = new ParForStatementBlock();
			} 
			else if (current instanceof ForStatement) {
				sb = new ForStatementBlock();
			}
			else if (current instanceof FunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}
			else if (current instanceof ExternalFunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}

			else if (current instanceof CVStatement) {
				LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
				LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
				LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
			else {
				sb = new StatementBlock();
			}
			sb.addStatement(current);
			fs.addStatementBlock(sb);
		}
	)*
   	tEnd = <RIGHTCURLYPAREN>
   
 	{
		fs.mergeStatementBlocks();

		// track position for statement
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		fs.setAllPositions(blp, bcp, elp, ecp);
		
		return fs;
 	}
}


ParForStatement ParForStatement() :
{
	ParForStatement fs = new ParForStatement();
	Statement current = null;
	IterablePredicate ip = null;
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
 
	tStart = <PARFOR> ip = IterablePredicate() {fs.setPredicate(ip);}
	<LEFTCURLYPAREN>
  	(
		(
			LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
   			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
			| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
			| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
			| LOOKAHEAD(ExternalFunctionStatement())	current = ExternalFunctionStatement()
			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
			| LOOKAHEAD(ForStatement())					current = ForStatement()
			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
			| LOOKAHEAD(IfStatement())					current = IfStatement()
			| LOOKAHEAD(CVStatement())					current = CVStatement()
			| LOOKAHEAD(ELStatement())					current = ELStatement()
			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
 
 		)
 		{
			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
				sb = new WhileStatementBlock();
			}
			else if (current instanceof IfStatement) {
				sb = new IfStatementBlock();
			}
			else if (current instanceof ParForStatement) {
				sb = new ParForStatementBlock();
			}
			else if (current instanceof ForStatement) {
				sb = new ForStatementBlock();
			}
			else if (current instanceof FunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}
			else if (current instanceof ExternalFunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}

			else if (current instanceof CVStatement) {
				LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
				LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
				LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
			
			else {
				sb = new StatementBlock();
			}
			sb.addStatement(current);
			fs.addStatementBlock(sb);
		}
	)*
  	tEnd = <RIGHTCURLYPAREN>
   
 	{
  		fs.mergeStatementBlocks();

		// track position for statement
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		fs.setAllPositions(blp, bcp, elp, ecp);

		return fs;
 	}
}


WhileStatement WhileStatement() :
{
	WhileStatement ws = new WhileStatement();
	Statement current = null;
	ConditionalPredicate cp = null;
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	tStart = <WHILE> cp = ConditionalPredicate() {ws.setPredicate(cp);}
  	<LEFTCURLYPAREN>
  	(
		(
			LOOKAHEAD(RandStatement()) 	  				current = RandStatement()
   			| LOOKAHEAD(AssignmentStatement()) 			current = AssignmentStatement() 
   			| LOOKAHEAD(MultiAssignmentStatement()) 	current = MultiAssignmentStatement()
   			| LOOKAHEAD(InputStatement()) 				current = InputStatement() 
			| LOOKAHEAD(FunctionStatement()) 			current = FunctionStatement()
			| LOOKAHEAD(ExternalFunctionStatement()) 	current = ExternalFunctionStatement()
			| LOOKAHEAD(OutputStatement())				current = OutputStatement()
			| LOOKAHEAD(PrintStatement())				current = PrintStatement()
			| LOOKAHEAD(WhileStatement())				current = WhileStatement()
			| LOOKAHEAD(ForStatement())					current = ForStatement()
			| LOOKAHEAD(ParForStatement())				current = ParForStatement()
			| LOOKAHEAD(IfStatement())					current = IfStatement()
 			| LOOKAHEAD(CVStatement())					current = CVStatement()
 			| LOOKAHEAD(ELStatement())					current = ELStatement()
 			| LOOKAHEAD(ELUseStatement())				current = ELUseStatement()
 
		)
		{
			StatementBlock sb = null;
			if (current instanceof WhileStatement) {
		   		sb = new WhileStatementBlock();
		  	}
		  	else if (current instanceof IfStatement) {
		   		sb = new IfStatementBlock();
		  	}
		  	else if (current instanceof ParForStatement) {
		   		sb = new ParForStatementBlock();
		  	}
		  	else if (current instanceof ForStatement) {
		   		sb = new ForStatementBlock();
		  	}
		 	else if (current instanceof FunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}
			else if (current instanceof ExternalFunctionStatement) {
			  	LOG.error(current.printErrorLocation() + " Nested function definitions are not supported ");
				throw new ParseException(current.printErrorLocation() + " Nested function definitions are not supported ");
			}

			else if (current instanceof CVStatement) {
				LOG.error(current.printErrorLocation() + "\"crossval\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"crossval\" not supported in DML");
				//sb = new CVStatementBlock();
			}
			else if (current instanceof ELStatement) {
				LOG.error(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"ensemble\" not supported in DML");
				//sb = new ELStatementBlock();
			}
			else if (current instanceof ELUseStatement) {
				LOG.error(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				throw new ParseException(current.printErrorLocation() + "\"use ensemble\" not supported in DML");
				//sb = new ELUseStatementBlock();
			}   
		  	else {
	   			sb = new StatementBlock();
	  		}
	  		sb.addStatement(current);
	  		ws.addStatementBlock(sb);
		}
	)*
  	tEnd = <RIGHTCURLYPAREN>
   
 {
	ws.mergeStatementBlocks();

	// track position for statement
	blp = tStart.beginLine;
	bcp = tStart.beginColumn;
	elp = tEnd.beginLine;
	ecp = tEnd.beginColumn;
	ws.setAllPositions(blp, bcp, elp, ecp);

	return ws;
 }
}

IterablePredicate IterablePredicate() :
{
	 DataIdentifier iterVar = null;
	 Expression fromExpr = null, toExpr = null, incrementExpr = null;
	 FunctionCallIdentifier fci = null;
	 Token paramName = null, paramVal = null;
	 HashMap<String,String> parforParamValues = new HashMap<String,String>();
	 ArrayList<Expression> exprParams = new ArrayList<Expression>();

	 Token tStart = null, tEnd = null, tSeq = null, tIn = null;
	 int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	tStart = <LEFTPAREN>

 	iterVar = Identifier() tIn = <ID> (  exprParams = ColonDelimitedExpression() | (tSeq = <SEQ> fci = FunctionCall()) )
   	(<COMMA> paramName = <ID> <ASSIGN> (paramVal = <INTEGER> | paramVal = <ID>) { parforParamValues.put(paramName.image, paramVal.image); } )*
	{

		if (tIn != null && !tIn.image.equals("in")){
            LOG.error(printErrorLocation(tIn.beginLine, tIn.beginColumn) +"for iterable predicate, token after variable must be \"in\""); 
			throw new ParseException(printErrorLocation(tIn.beginLine, tIn.beginColumn) +"for iterable predicate, token after variable must be \"in\""); 
		}
   		if (fci == null && exprParams == null){   		    LOG.error(printErrorLocation(tStart.beginLine, tStart.beginColumn) + "iterable predicate in for loop must specify parameters"); 
  			throw new ParseException(printErrorLocation(tStart.beginLine, tStart.beginColumn) + "iterable predicate in for loop must specify parameters"); 
		}
		if (fci != null) {
    		ArrayList<Expression> seqExprs = fci.getParamExpressions();

    		if (seqExprs.size() <  2){    		    LOG.error(printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq must specify both from and to value");
    			throw new ParseException(printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq must specify both from and to value");
			}
    		if (seqExprs.size() > 3) {    		    LOG.error(printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq cannot specify more than 3 args -- from, to, increment");
    			throw new ParseException(printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq cannot specify more than 3 args -- from, to, increment");
  			}
    		else {
     			fromExpr = seqExprs.get(0);
     			toExpr   = seqExprs.get(1);
     			IntIdentifier oneExpr = new IntIdentifier(1);
     			((IntIdentifier)oneExpr).setDimensions(0,0);
				((IntIdentifier)oneExpr).computeDataType();
				((IntIdentifier)oneExpr).setValueType(ValueType.INT);
     			incrementExpr = (seqExprs.size() == 3) ? seqExprs.get(2) : oneExpr;  
    		} 
    
   		}
   		else {
    		// use exprParams
    		fromExpr = exprParams.get(0);
    		toExpr   = exprParams.get(1);
    		incrementExpr = new IntIdentifier(1);
    		((IntIdentifier)incrementExpr).setDimensions(0,0);
			((IntIdentifier)incrementExpr).computeDataType();
			((IntIdentifier)incrementExpr).setValueType(ValueType.INT);
    		
   		}
    	// if (params.size() > 2)
  	}
  
 	tEnd = <RIGHTPAREN>
 	{
 		IterablePredicate retVal = new IterablePredicate(iterVar, fromExpr, toExpr, incrementExpr, parforParamValues);

		// track position for statement
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		retVal.setAllPositions(blp, bcp, elp, ecp);
		
		return retVal;
	}
}


ConditionalPredicate ConditionalPredicate() :  
{
	Expression expr = null;
	Token tStart = null, tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	tStart = <LEFTPAREN> expr = BooleanOrExpression() tEnd = <RIGHTPAREN>
	{
		ConditionalPredicate retVal = new ConditionalPredicate(expr);

		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		retVal.setAllPositions(blp, bcp, elp, ecp);

		return retVal;
	}
}


Expression Expression() : 
{
	Expression expr = null;
}
{
	(expr = BooleanOrExpression())
	{
		return expr;
	}
}


Expression BooleanOrExpression() :  
{
	Expression expr = null;
	Token t = null;
}
{
	expr = BooleanAndExpression() 
	(
		{
			Expression left = null, right = null;
		  	Expression.BooleanOp bop = null;
		  	
		}
		(
			t = <CONDITIONALOR> | t = <LOGICALOR>
		) 
		{
			bop = Expression.getBooleanOp(t.image);
		}
     	right = BooleanAndExpression() 
     	{
        	left = expr;
			BooleanExpression exprb = new BooleanExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn );
			exprb.setLeft(left);
			exprb.setRight(right);
			expr = exprb;
		}
	)*
 	{
		return expr;
	}
}

 
Expression BooleanAndExpression() : 
{
	Expression expr = null;
	Token t = null;
}
{
	expr = BooleanNotExpression() 
 	(
    	{
   			Expression left = null, right = null;
   			Expression.BooleanOp bop = null;
   			
   		}
    
     	(t = <CONDITIONALAND> | t = <LOGICALAND>) 
     	{bop = Expression.getBooleanOp(t.image); }
     	right = BooleanNotExpression() 
      	{
			left = expr;
       		BooleanExpression exprb = new BooleanExpression(bop, t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
       		exprb.setLeft(left);
       		exprb.setRight(right);
       		expr = exprb;
      	}
    )*
	{	
		return expr;
	}
}


Expression BooleanNotExpression() : 
{
	Expression expr = null; Token t = null;
}
{
	[ t = <NOT> ] expr = RelationalExpression() 
     
    {
      	if (t == null)
     		return expr;
     
   		Expression.BooleanOp bop = Expression.getBooleanOp(t.image); 
   		Expression left = expr;
   		BooleanExpression notexpr = new BooleanExpression(bop, t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
   		notexpr.setLeft(left);
   		return notexpr;
  	}
}


Expression RelationalExpression() :
{
	Expression expr = null;
	Token t = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	
}
{
	expr = PlusMinusExpression() 
	(
    	{Expression left = null, right = null; Expression.RelationalOp bop = null;}
   		(t=<LESSEQUAL> | t=<LESS> | t=<GREATEREQUAL> | t=<GREATER> | t=<EQUAL> | t=<NOTEQUAL>) 
   		{bop = Expression.getRelationalOp(t.image); }

     	right =  PlusMinusExpression() 
       	{
        	left = expr;
			RelationalExpression exprb = new RelationalExpression(bop, t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
       		exprb.setLeft(left);
      	 	exprb.setRight(right);
       		expr = exprb;
      	}
	)*
 	{
   		return expr;
   	}
}


Expression PlusMinusExpression() : 
{
	Expression expr = null;
	Token t = null;
}
{
	expr = MultDivExpression() 
 	(
   		{Expression left, right; Expression.BinaryOp bop = null;}
    	(t = <PLUS> | t = <MINUS>)  {bop = Expression.getBinaryOp(t.image); }
   		right = MultDivExpression() 
    	{
     		left = expr;
    		BinaryExpression exprb = new BinaryExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
    		exprb.setLeft(left);
    		exprb.setRight(right);
    		expr = exprb;
   		}
	)*
 	{ 
		return expr;
	}
}


Expression MultDivExpression() : 
{
	Expression expr = null;
	Token t = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	expr = MatrixMultExpression() 
 	(
   		{Expression left, right; Expression.BinaryOp bop = null;}
   		(t = <MULT> | t = <DIV>)  {bop = Expression.getBinaryOp(t.image); }
   		right = MatrixMultExpression() 
   		{
		    left = expr;
		    BinaryExpression exprb = new BinaryExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
		    exprb.setLeft(left);
		    exprb.setRight(right);
		    expr = exprb;
   		}
    )*
 	{
		return expr;
	}
}


Expression MatrixMultExpression() : 
{
	Expression expr = null;
	Token t = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	expr = UnaryExpression() 
 	(
 		{Expression left, right; Expression.BinaryOp bop = null; }
  		t = <MATRIXMULT>  {bop = Expression.getBinaryOp(t.image); }
 	 	right =  UnaryExpression() 
 		{
			left = expr;
			BinaryExpression exprb = new BinaryExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
			exprb.setLeft(left);
			exprb.setRight(right);
			expr = exprb;
   		}
    )*
	{
		return expr;
	}
}


Expression UnaryExpression() : 
{
	Expression expr = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	Token t = null;
}
{
	(
	  	LOOKAHEAD(3) expr = PowerExpression() |
	  	(
   			{Expression right = null; BinaryOp bop = null;}
   			(t = <PLUS> | t =  <MINUS>)  {bop = Expression.getBinaryOp(t.image); }
   			right = PowerExpression() 

     		{
				BinaryExpression exprb = new BinaryExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
     			IntIdentifier id = new IntIdentifier(0);
				id.setDimensions(0,0);
				id.computeDataType();
				id.setValueType(ValueType.INT);
				exprb.setLeft(id);
				exprb.setRight(right);
				expr = exprb;
     		}
     	)
	)
	{
		return expr;
	}
}


Expression PowerExpression() : 
{
	Expression expr = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	Token t = null;
}
{
	expr = PrimaryExpression() 
  	[ 
   		{
   			Expression left = null, right = null;
   			Expression.BinaryOp bop = null;
   		}
    	t = <POWER>  {bop = Expression.getBinaryOp(t.image); }

   		right = PowerExpression() 
    	{
     		left = expr;
			BinaryExpression exprb = new BinaryExpression(bop, t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
    		exprb.setLeft(left);
    		exprb.setRight(right);
    		expr = exprb;
   		}
    ]
	{
		return expr;
	}
}


Expression PrimaryExpression() : 
{
	Expression expr = null;
}
{
	( LOOKAHEAD(2) expr = IdentifierOrConstant()
  		| <LEFTPAREN> expr = Expression() <RIGHTPAREN>
   	)
	{
		// position info for expression already set
		return expr;
	} 
}

Identifier IdentifierOrConstant() :
{
 	Identifier id = null;
 	Token t1 = null;
}
{
	(

		t1 = <DOLLAR_ID>
		{
	
			///////// BEGIN handle variable param ///////////////
		
			String argVal = commandArgs.get(t1.image);

			if (argVal == null)			{			    LOG.error(printErrorLocation(t1.beginLine, t1.beginColumn) + " value for " + t1.image + " is undefined ");
				throw new ParseException(printErrorLocation(t1.beginLine, t1.beginColumn) + " value for " + t1.image + " is undefined ");
			}				
			try {
			  	// try to assign to long value
				Long longVal = new Long(argVal);
				id = new IntIdentifier(longVal);
				id.setDimensions(0,0);
		    	id.computeDataType();
		    	id.setValueType(ValueType.INT);
				
			} catch(Exception e1){
			  	try {
			  	  	// try to assign to double value
			  	  	Double doubleVal = new Double(argVal);
			  	  	id = new DoubleIdentifier(doubleVal);
				  	id.setDimensions(0,0);
	    		  	id.computeDataType();
	    		  	id.setValueType(ValueType.DOUBLE);
			  	  
			  	} catch (Exception e2) {

					// try to assign to boolean value
					if (argVal.equalsIgnoreCase("true") || argVal.equalsIgnoreCase("false")){   
						Boolean boolVal = new Boolean(argVal);
			  	  		id = new BooleanIdentifier(boolVal);
						id.setDimensions(0,0);
	    				id.computeDataType();
	    				id.setValueType(ValueType.BOOLEAN);
					}
					else {
					  	// try to assign to string value
						id = new StringIdentifier(argVal);
						id.setDimensions(0,0);
	    				id.computeDataType();
	    				id.setValueType(ValueType.STRING);
					}	

			  	} // end catch e2
				  						  	 
			} // end catch e1
	
	   	}
		///////// END handle variable param ///////////////
				
		|	id = Identifier()
		| 	id = Constant()

	)
	{ 
		// only set positions for command-line parameters (which are not initialized)
		if (t1 != null) {
			id.setAllPositions(t1.beginLine, t1.beginColumn, t1.beginLine, t1.beginColumn);
		}
		
		return id; 
	}
}


ConstIdentifier Constant() :
{
	Token t = null;
	Boolean minus = false;
	ConstIdentifier id = null;
}
{
   (
      LOOKAHEAD(2) id = IntConstant()
      | id = DoubleConstant()
      | id = BooleanConstant()
      | id = StringConstant()
    )
 	{
 	  	// position for id already set
  		return id; 
 	}
}


IntIdentifier IntConstant() :
{
	Token t = null;
	Boolean minus = false;
	IntIdentifier id = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	(<MINUS > {minus = true;})?
 	(
  		t = <INTEGER>
  		{
     		long intval = Long.parseLong(t.image);
     		if (minus)
     		{
     			intval = -intval;
     		}

   			id = new IntIdentifier(intval);
   			id.setDimensions(0,0);
      		id.computeDataType();
      		id.setValueType(ValueType.INT);
  		}
 	)
 	{
 	  	blp = t.beginLine;
		bcp = t.beginColumn;
		elp = t.endLine;
		ecp = t.endColumn;
		id.setAllPositions(blp, bcp, elp, ecp);
 		return id; 
 	}
}


DoubleIdentifier DoubleConstant() :
{
	Token t;
	Boolean minus = false;
	DoubleIdentifier id = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	(<MINUS > {minus = true;})?
 	(
		t = <DOUBLE>
		{
      		Double doubleval = Double.parseDouble(t.image);
      		if (minus)
      		{
        		doubleval = -doubleval;
      		}
   			id = new DoubleIdentifier(doubleval);
   			id.setDimensions(0,0);
      		id.computeDataType();
      		id.setValueType(ValueType.DOUBLE);
  		}
 	)
 	{ 
		blp = t.beginLine;
		bcp = t.beginColumn;
		elp = t.endLine;
		ecp = t.endColumn;
		id.setAllPositions(blp, bcp, elp, ecp);
 		return id; 
 	}
}


BooleanIdentifier BooleanConstant() :
{
	Token t;
	BooleanIdentifier id = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
    (
  		((t = <TRUE>) | (t =<FALSE>))
  		{
   			id = new BooleanIdentifier(Boolean.parseBoolean(t.image));
   			id.setDimensions(0,0);
			id.computeDataType();
			id.setValueType(ValueType.BOOLEAN);
  		}
 	)
 	{
 	  	blp = t.beginLine;
		bcp = t.beginColumn;
		elp = t.endLine;
		ecp = t.endColumn;
		id.setAllPositions(blp, bcp, elp, ecp);
 		return id; 
 	}
}


StringIdentifier StringConstant() :
{
	Token t = null;
	StringIdentifier id = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
    (
  		(t =<DBLQUOTE_STRING_LITERAL>)
  		{
			id = new StringIdentifier(dequoteStr('\"',t.image));
   			id.setDimensions(0,0);
      		id.computeDataType();
      		id.setValueType(ValueType.STRING);
  		}
 	)
 	{ 
		blp = t.beginLine;
		bcp = t.beginColumn;
		elp = t.endLine;
		ecp = t.endColumn;
		id.setAllPositions(blp, bcp, elp, ecp);
 		return id; 
 	}
}

DataIdentifier Identifier() :
{
	Token t = null;
	Token tNamespace = null;
	DataIdentifier id = null;
	FunctionCallIdentifier functCall = null;
	ArrayList<ArrayList<Expression>> exprListList = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	[LOOKAHEAD(4)tNamespace = <ID>{ blp=tNamespace.beginLine; bcp=tNamespace.beginColumn; elp =tNamespace.endLine; ecp = tNamespace.endColumn;} <COLON><COLON>]
			t = <ID> { if (tNamespace == null ) { blp=t.beginLine; bcp=t.beginColumn;} elp= t.endLine; ecp =t.endColumn; }
			(LOOKAHEAD(FunctionCall()) functCall = FunctionCall()  | exprListList = ReadIndexList())?

  	{
		id = new DataIdentifier(t.image);
  
		if (functCall != null) {

			// CASE: no namespace handle built-in functions
			if ( tNamespace == null )
			{
				// verify passed function name is a (non-parameterized) built-in function.
				BuiltinFunctionExpression bife = BuiltinFunctionExpression.getBuiltinFunctionExpression(t.image, functCall.getParamExpressions());
				if (bife != null){
					bife.setAllPositions(blp, bcp, functCall.getEndLine(), functCall.getEndColumn());
					return bife;
				}
				ParameterizedBuiltinFunctionExpression pbife = ParameterizedBuiltinFunctionExpression.getParamBuiltinFunctionExpression(t.image, functCall.getNamedParamExpressions());
				if (pbife != null){
					pbife.setAllPositions(blp, bcp, functCall.getEndLine(), functCall.getEndColumn());
					return pbife;
				}
			}

			// handle UDF function call
			String namespaceName = (tNamespace == null) ? DMLProgram.DEFAULT_NAMESPACE : tNamespace.image;
		    functCall.setFunctionNamespace(namespaceName);
		    functCall.setFunctionName(t.image);

			// set position information
			functCall.setAllPositions(blp, bcp, functCall.getEndLine(), functCall.getEndColumn());
		   	return functCall;
		}
		else if (exprListList != null){
			IndexedIdentifier iid = new IndexedIdentifier(id.getName(), false, false);
			try {
				iid.setIndices(exprListList);
			} catch (ParseException e) {
				LOG.error(printErrorLocation(blp,bcp) + "matrix indices must be specified for 2 dimensions -- currently specified indices for " + exprListList.size() + " dimensions ");
				throw new ParseException(printErrorLocation(blp,bcp) + "matrix indices must be specified for 2 dimensions -- currently specified indices for " + exprListList.size() + " dimensions ");
			}
			
			// set position information
			iid.setAllPositions(blp, bcp, exprListList);
						
		   	return iid;
		} else{

			// set position information
			id.setAllPositions(blp, bcp, elp, ecp);
			return id;
		}
 	}
}


FunctionCallIdentifier FunctionCall():
{
	Expression expr = null;
	FunctionCallIdentifier functCall = null;
	ArrayList<Expression> exprs = new ArrayList<Expression>();
	HashMap<String, Expression> namedExprs = new HashMap<String,Expression>(); 
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	Token tStart = null, tEnd = null, t1 = null;
}
{
	tStart = <LEFTPAREN>
		(
		  	(LOOKAHEAD(2) t1 = <ID> <ASSIGN>)? expr = Expression()
			{
				if (t1 != null){
					namedExprs.put(t1.image, expr);
				}	
				else {
				   exprs.add(expr);
				}
				t1 = null;
			}
		)


		(
			<COMMA> (LOOKAHEAD(2) t1= <ID> <ASSIGN>)?  expr = Expression()
			{
				if (t1 != null){
					namedExprs.put(t1.image, expr);
				}	
				else {
				   exprs.add(expr);
				}
				t1 = null;
			}
		)*
	tEnd = <RIGHTPAREN>  
	{
		functCall = new FunctionCallIdentifier(exprs, namedExprs);

		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		functCall.setAllPositions(blp, bcp, elp, ecp);
		
		return functCall;
	}     
}


InputStatement InputStatement() :
{
	DataIdentifier id = null;
	InputStatement is = new InputStatement(Expression.DataOp.READ);
	Expression t2 = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	Token tEnd = null;
	Token tRead = null;
}
{
	  	id = Identifier()
	
	  	{
			if (id.getName().startsWith("$")){				LOG.error(printErrorLocation(id.getBeginLine(), id.getBeginColumn()) + "command-line parameter " + id.getName() + " cannot be assigned a value");
				throw new ParseException(printErrorLocation(id.getBeginLine(), id.getBeginColumn()) + "command-line parameter " + id.getName() + " cannot be assigned a value");
			}
  	  	}
	  	<ASSIGN> (tRead = <READMATRIX> | tRead = <READMM> | tRead = <READ_MATRIX> ) <LEFTPAREN>
		t2 = Expression() {is.addExprParam(Statement.IO_FILENAME,t2,false);}
				
		//(< COMMA >(Token t1 = <ID> < ASSIGN > Expression t2 = Expression() {is.addExprParam(t1.image, t2);}))*
		(
			<COMMA>
			(
				{Token t1 = null;}
				t1 = <ID> < ASSIGN > t2 = Expression() {is.addExprParam(t1.image, t2,false);}
			)
		)*
		tEnd = <RIGHTPAREN> [<SEMICOLON>]
	{

		if (tRead.image.equals("readMM")){
		    StringIdentifier readMMExpr = new StringIdentifier(Statement.FORMAT_TYPE_VALUE_MATRIXMARKET);
		    readMMExpr.setDimensions(0,0);
	    	readMMExpr.computeDataType();
	    	readMMExpr.setValueType(ValueType.STRING);
			is.addExprParam(Statement.FORMAT_TYPE, readMMExpr, false);
		}
		else if (tRead.image.equals("read.matrix")){
		  	StringIdentifier readMMExpr = new StringIdentifier(Statement.FORMAT_TYPE_VALUE_DELIMITED);
		    readMMExpr.setDimensions(0,0);
	    	readMMExpr.computeDataType();
	    	readMMExpr.setValueType(ValueType.STRING);
			is.addExprParam(Statement.FORMAT_TYPE, readMMExpr, false);			
		}

		
 		is.setIdentifier(id);
 		id.setDimensions(is);
 		id.computeDataType();
	
		blp = id.getBeginLine();
		bcp = id.getBeginColumn();
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		is.setAllPositions(blp, bcp, elp, ecp);
 		
 		return is;
	}
}


OutputStatement OutputStatement() :
{
	DataIdentifier fn = null;
	Token t1 = null;
	Expression t2 = null;
	OutputStatement os = null;

	Token tStart = null, tEnd = null;
	Token tWrite = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
}
{
	(tStart = <WRITEMATRIX> | tStart = <WRITEMM> | tStart = <WRITE_MATRIX> ) <LEFTPAREN>
		fn = Identifier() { os = new OutputStatement(fn, Expression.DataOp.WRITE); } <COMMA>
    	t2 = Expression() { os.addExprParam(Statement.IO_FILENAME,t2,false); }
     	(
			<COMMA>
			(
				t1 = <ID> <ASSIGN> t2 = Expression()
				{
					os.addExprParam(t1.image, t2,false);
				}
			)
		)*
		tEnd = <RIGHTPAREN>  [<SEMICOLON>]
	{
		tWrite = tStart;
		if (tWrite.image.equals("writeMM")){

			StringIdentifier writeMMExpr = new StringIdentifier(Statement.FORMAT_TYPE_VALUE_MATRIXMARKET);
		  	writeMMExpr.setDimensions(0,0);
	    	writeMMExpr.computeDataType();
	    	writeMMExpr.setValueType(ValueType.STRING);			os.addExprParam(Statement.FORMAT_TYPE, writeMMExpr,false);
		}
		else if (tWrite.image.equals("write.matrix")){
			StringIdentifier delimitedExpr = new StringIdentifier(Statement.FORMAT_TYPE_VALUE_MATRIXMARKET);
		  	delimitedExpr.setDimensions(0,0);
	    	delimitedExpr.computeDataType();
	    	delimitedExpr.setValueType(ValueType.STRING);
			os.addExprParam(Statement.FORMAT_TYPE, delimitedExpr, false);
		}	
		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		os.setAllPositions(blp, bcp, elp, ecp);
		return os;
	}
}


PrintStatement PrintStatement() :
{
	Expression source;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	Token tStart = null, tEnd = null;
}
{
	tStart = <PRINT> <LEFTPAREN> source = Expression()  tEnd = <RIGHTPAREN>  [<SEMICOLON>]
	{	
		PrintStatement retVal = new PrintStatement(source);

		blp = tStart.beginLine;
		bcp = tStart.beginColumn;
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		retVal.setAllPositions(blp, bcp, elp, ecp);

		return retVal;
	}
}


void RelationalOp() :
{}
{
	(<LESS> | <GREATER> | <GREATEREQUAL> | <LESSEQUAL> | <EQUAL> | <NOTEQUAL>)
}


RandStatement RandStatement() :
{
	RandStatement rs = null;
	DataIdentifier id = null;
	Token t1 = null;
	Expression t2 = null;
	
	Token tEnd = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	
}
{
	id = Identifier() <ASSIGN> <RAND> <LEFTPAREN>
	{
		rs = new RandStatement(id);
	}
	(
		( t1 = <ID> ) <ASSIGN> t2 = Expression() { rs.addExprParam(t1.image, t2); }
		( <COMMA> (t1 = <ID>) <ASSIGN> t2 = Expression() { rs.addExprParam(t1.image, t2); })*
	)
	tEnd = <RIGHTPAREN> [<SEMICOLON>]
	{
		blp = id.getBeginLine();
		bcp = id.getBeginColumn();
		elp = tEnd.beginLine;
		ecp = tEnd.beginColumn;
		rs.setAllPositions(blp, bcp, elp, ecp);
		rs.setRandDefault();
		return rs;
	}
}


ELStatement ELStatement() :
{
	Token t = null, tOn = null, tPartition = null, tTrain = null, tTest = null;
	Token tAs_1 = null, tAs_2 = null, tAs_3 = null;
	String eNameStr = null; 
	CVStatement.AGG agg = null ;

	HashMap<String,String> partitionParams = null;
	ArrayList<String> dataList = new ArrayList<String>();
	String trainFunctionName = null, testFunctionName = null ;

  	ArrayList<String> partitionOutputs = new ArrayList<String>(), trainFunctionParams = new ArrayList<String>(),
		trainFunctionOutputs = new ArrayList<String>(), testFunctionParams = new ArrayList<String>(),
		testFunctionOutputs = new ArrayList<String>(), errorAggFunctionParams = new ArrayList<String>(),
		errorAggFunctionOutputs = new ArrayList<String>();

}
{
	<BUILD_ENSEMBLE> t = <ID> { eNameStr = t.image; } tOn = <ID> dataList = ReadList()
 	tPartition = <ID> partitionParams = ReadGenericParamList() 												  tAs_1	= <ID> partitionOutputs = ReadList()
	tTrain = <ID> t = <ID> {  trainFunctionName = t.image;  } trainFunctionParams = ReadList()  			  tAs_2 = <ID> trainFunctionOutputs = ReadList()
	[LOOKAHEAD(2) tTest = <ID>  t = <ID> { testFunctionName  = t.image;  } testFunctionParams  = ReadList()   tAs_3 = <ID> testFunctionOutputs  = ReadList()]

 	{
		// verify that "as" tokens have correct value
		if (!"on".equals(tOn)) throw new ParseException(printErrorLocation(tOn.beginLine, tOn.beginColumn) + "incorrect syntax for build ensemble -- should be \"build ensemble <name> on (data list)\"");
		if (!"as".equals(tAs_1)) throw new ParseException(printErrorLocation(tAs_1.beginLine, tAs_1.beginColumn) + "incorrect syntax for build ensemble -- should be \"(partition params) as (partition outputs)\"");
		if (!"as".equals(tAs_2)) throw new ParseException(printErrorLocation(tAs_2.beginLine, tAs_2.beginColumn) + "incorrect syntax for build ensemble -- should be \"(error agg params) as (error agg outputs)\"");
		if (tAs_3 != null &&  !"as".equals(tAs_3)) throw new ParseException(printErrorLocation(tAs_3.beginLine, tAs_3.beginColumn) + "incorrect syntax for build ensemble -- should be \"(error agg params) as (error agg outputs)\"");
	
		MetaLearningFunctionParameters params = new MetaLearningFunctionParameters(
				trainFunctionName, trainFunctionParams, trainFunctionOutputs, 
				testFunctionName,  testFunctionParams,  testFunctionOutputs, 
				partitionOutputs, 
				agg, errorAggFunctionParams, errorAggFunctionOutputs); 

		return new ELStatement(eNameStr, dataList, partitionParams, params) ;
	}
}


ELUseStatement ELUseStatement() :
{
	Token t = null, aggfunc = null, tOn = null, tTest = null, tAgg = null;
	Token tAs_1 = null, tAs_2 = null;
  	String eNameStr = null;
 	HashMap<String,String> partitionParams = null;
  	String trainFunctionName = null, testFunctionName = null ;

	ArrayList<String> dataList = new ArrayList<String>(), partitionOutputs = new ArrayList<String>(),
    trainFunctionParams = new ArrayList<String>(),trainFunctionOutputs = new ArrayList<String>(),
    testFunctionParams = new ArrayList<String>(), testFunctionOutputs = new ArrayList<String>(),
    errorAggFunctionParams = new ArrayList<String>(), errorAggFunctionOutputs = new ArrayList<String>();
 
}
{
	<USE_ENSEMBLE> t = <ID> { eNameStr = t.image; } tOn = <ID> dataList = ReadList()
    tTest = <ID>  t = <ID> { testFunctionName  = t.image;  } testFunctionParams  = ReadList() tAs_1 = <ID> testFunctionOutputs     = ReadList()
 	tAgg  = <ID> (aggfunc = <ID>) errorAggFunctionParams = ReadList() 						  tAs_2 = <ID> errorAggFunctionOutputs = ReadList()

	{
		CVStatement.AGG agg = null ;
		if("sum".equals(aggfunc.image))
			agg = CVStatement.AGG.sum ;
		else if("avg".equals(aggfunc.image))
			agg = CVStatement.AGG.avg ;

		// verify that "as" tokens have correct value
		if (!"on".equals(tOn))   throw new ParseException(printErrorLocation(tOn.beginLine, tOn.beginColumn) + "incorrect syntax for use ensemble -- should be \"use ensemble <name> on (data list)\"");
		if (!"as".equals(tAs_1)) throw new ParseException(printErrorLocation(tAs_1.beginLine, tAs_1.beginColumn) + "incorrect syntax for use ensemble -- should be \"(test params) as (test outputs)\"");
		if (!"as".equals(tAs_2)) throw new ParseException(printErrorLocation(tAs_2.beginLine, tAs_2.beginColumn) + "incorrect syntax for use ensemble -- should be \"(error agg params) as (error agg outputs)\"");
	
		MetaLearningFunctionParameters params = new MetaLearningFunctionParameters(
				trainFunctionName, trainFunctionParams, trainFunctionOutputs, 
     	  		testFunctionName,  testFunctionParams,  testFunctionOutputs, 
       			partitionOutputs, 
       			agg, errorAggFunctionParams, errorAggFunctionOutputs); 

		return new ELUseStatement(eNameStr, dataList, partitionParams, params) ;
 	}

}


CVStatement CVStatement() :
{
	Token t;
	String trainFunctionName = null, testFunctionName = null ;
	ArrayList<String> inputs = new ArrayList<String>(), partitionOutputs = new ArrayList<String>(),
	trainFunctionParams = new ArrayList<String>(),trainFunctionOutputs = new ArrayList<String>(),
	testFunctionParams = new ArrayList<String>(), testFunctionOutputs = new ArrayList<String>(),
	errorAggFunctionParams = new ArrayList<String>(), errorAggFunctionOutputs = new ArrayList<String>();

	CVStatement.AGG agg = null ;
	HashMap<String,String> partitionParams ;

	Token 	aggfunc = null;
	Token	tPartition = null, tAs_1 = null;
	Token	tTrain = null, tAs_2 = null;
	Token   tTest = null,  tAs_3 = null;
	Token	tAgg = null,   tAs_4 = null;
}
{
	<CROSSVAL> inputs = ReadList()
 	tPartition = <ID> partitionParams = ReadGenericParamList() 									  tAs_1 = <ID> partitionOutputs = ReadList()
 	tTrain     = <ID> t = <ID> { trainFunctionName = t.image; } trainFunctionParams = ReadList()  tAs_2 = <ID> trainFunctionOutputs = ReadList()
 	tTest  = <ID>  t = <ID> { testFunctionName  = t.image; }    testFunctionParams  = ReadList()  tAs_3 = <ID> testFunctionOutputs  = ReadList()
 	tAgg   = <ID> (aggfunc = <ID>) errorAggFunctionParams = ReadList() 							  tAs_4 = <ID> errorAggFunctionOutputs = ReadList()

 	{
		if("sum".equals(aggfunc.image))
    		agg = CVStatement.AGG.sum;
   		else if("avg".equals(aggfunc.image))
    		agg = CVStatement.AGG.avg;

		// verify that "as" tokens have correct value
		if (!"as".equals(tAs_1)) throw new ParseException(printErrorLocation(tAs_1.beginLine, tAs_1.beginColumn) + "incorrect syntax for crossval -- should be \"(partition params) as (partition outputs)\"");
		if (!"as".equals(tAs_2)) throw new ParseException(printErrorLocation(tAs_2.beginLine, tAs_2.beginColumn) + "incorrect syntax for crossval -- should be \"(train params) as (train outputs)\"");
		if (!"as".equals(tAs_3)) throw new ParseException(printErrorLocation(tAs_3.beginLine, tAs_3.beginColumn) + "incorrect syntax for crossval -- should be \"(test params) as (test outputs)\"");
		if (!"as".equals(tAs_4)) throw new ParseException(printErrorLocation(tAs_4.beginLine, tAs_4.beginColumn) + "incorrect syntax for crossval -- should be \"(error agg params) as (error agg outputs)\"");
	
		MetaLearningFunctionParameters params = new MetaLearningFunctionParameters(
				trainFunctionName, trainFunctionParams, trainFunctionOutputs,
				testFunctionName,  testFunctionParams,  testFunctionOutputs,
				partitionOutputs,
				agg, errorAggFunctionParams, errorAggFunctionOutputs); 

		return new CVStatement(inputs, partitionParams, params) ;
 	}
}