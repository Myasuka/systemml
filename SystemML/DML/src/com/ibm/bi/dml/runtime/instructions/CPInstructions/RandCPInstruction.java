package com.ibm.bi.dml.runtime.instructions.CPInstructions;

import java.util.Random;

import org.apache.commons.math.random.Well1024a;

import com.ibm.bi.dml.hops.DataGenOp;
import com.ibm.bi.dml.hops.Hops.DataGenMethod;
import com.ibm.bi.dml.lops.Lops;
import com.ibm.bi.dml.parser.Expression.DataType;
import com.ibm.bi.dml.parser.Expression.ValueType;
import com.ibm.bi.dml.runtime.controlprogram.ExecutionContext;
import com.ibm.bi.dml.runtime.instructions.Instruction;
import com.ibm.bi.dml.runtime.instructions.InstructionUtils;
import com.ibm.bi.dml.runtime.matrix.io.MatrixBlock;
import com.ibm.bi.dml.runtime.matrix.operators.Operator;
import com.ibm.bi.dml.utils.DMLRuntimeException;

public class RandCPInstruction extends UnaryCPInstruction{
	public long rows;
	public long cols;
	public int rowsInBlock;
	public int colsInBlock;
	public double minValue;
	public double maxValue;
	public double sparsity;
	public String pdf;
	public long seed=0;
	public double seq_from, seq_to, seq_incr;
	DataGenMethod method = DataGenMethod.INVALID;
	
	/**
	 * A matrix of random numbers is generated by using multiple seeds, one for each 
	 * block. Such block-level seeds are produced via Well equidistributed long-period linear 
	 * generator (Well1024a). For a given seed, this function sets up the block-level seeds.
	 * 
	 * This function is invoked from both CP (RandCPInstruction.processInstruction()) 
	 * as well as MR (RandMR.java while setting up the Rand job).
	 * 
	 * @param seed
	 * @return
	 */
	public static Well1024a setupSeedsForRand(long seed) {
		long lSeed = (seed == DataGenOp.UNSPECIFIED_SEED ? DataGenOp.generateRandomSeed() : seed);
		LOG.trace("Setting up RandSeeds with initial seed = "+lSeed+".");

		Random random=new Random(lSeed);
		Well1024a bigrand=new Well1024a();
		//random.setSeed(lSeed);
		int[] seeds=new int[32];
		for(int s=0; s<seeds.length; s++)
			seeds[s]=random.nextInt();
		bigrand.setSeed(seeds);
		
		return bigrand;
	}
	
	public RandCPInstruction (Operator op, 
							  DataGenMethod mthd,
							  CPOperand in, 
							  CPOperand out, 
							  long rows, 
							  long cols,
							  int rpb, int cpb,
							  double minValue, 
							  double maxValue,
							  double sparsity, 
							  long seed,
							  String probabilityDensityFunction,
							  String istr) {
		super(op, in, out, istr);
		
		this.method = mthd;
		this.rows = rows;
		this.cols = cols;
		this.rowsInBlock = rpb;
		this.colsInBlock = cpb;
		this.minValue = minValue;
		this.maxValue = maxValue;
		this.sparsity = sparsity;
		this.seed = seed;
		this.pdf = probabilityDensityFunction;

	}

	public RandCPInstruction(Operator op, DataGenMethod mthd, CPOperand in, CPOperand out,
			long rows, long cols, int rpb, int cpb, double seqFrom,
			double seqTo, double seqIncr, String istr) {
		super(op, in, out, istr);
		this.method = mthd;
		this.rows = rows;
		this.cols = cols;
		this.rowsInBlock = rpb;
		this.colsInBlock = cpb;
		this.seq_from = seqFrom;
		this.seq_to = seqTo;
		this.seq_incr = seqIncr;
	}

	public static Instruction parseInstruction(String str) throws DMLRuntimeException 
	{
		String opcode = InstructionUtils.getOpCode(str);
		DataGenMethod method = DataGenMethod.INVALID;
		if ( opcode.equalsIgnoreCase("Rand") ) {
			method = DataGenMethod.RAND;
			InstructionUtils.checkNumFields ( str, 13 );
		}
		else if ( opcode.equalsIgnoreCase("seq") ) {
			method = DataGenMethod.SEQ;
			// 8 operands: rows, cols, rpb, cpb, from, to, incr, outvar
			InstructionUtils.checkNumFields ( str, 8 ); 
		}
		
		Operator op = null;
		CPOperand out = new CPOperand("", ValueType.UNKNOWN, DataType.UNKNOWN);
		String[] s = InstructionUtils.getInstructionPartsWithValueType ( str );
		out.split(s[s.length-1]); // ouput is specified by the last operand

		if ( method == DataGenMethod.RAND ) {
			long rows = -1, cols = -1;
	        if (!s[3].contains( Lops.VARIABLE_NAME_PLACEHOLDER)) {
			   	rows = Double.valueOf(s[3]).longValue();
	        }
	        if (!s[4].contains( Lops.VARIABLE_NAME_PLACEHOLDER)) {
	        	cols = Double.valueOf(s[4]).longValue();
	        }
			
			int rpb = Integer.parseInt(s[5]);
			int cpb = Integer.parseInt(s[6]);
			double minValue = Double.parseDouble(s[7]);
			double maxValue = Double.parseDouble(s[8]);
			double sparsity = Double.parseDouble(s[9]);
			long seed = Long.parseLong(s[10]);
			String pdf = s[11];
			
			return new RandCPInstruction(op, method, null, out, rows, cols, rpb, cpb, minValue, maxValue, sparsity, seed, pdf, str);
		}
		else if ( method == DataGenMethod.SEQ) {
			// Example Instruction: CP:seq:11:1:1000:1000:1:0:-0.1:scratch_space/_p7932_192.168.1.120//_t0/:mVar1
			long rows = Double.valueOf(s[1]).longValue();
			long cols = Double.valueOf(s[2]).longValue();
			int rpb = Integer.parseInt(s[3]);
			int cpb = Integer.parseInt(s[4]);
			
	        double from, to, incr;
	        from = to = incr = Double.NaN;
			if (!s[5].contains( Lops.VARIABLE_NAME_PLACEHOLDER)) {
				from = Double.valueOf(s[5]);
	        }
			if (!s[6].contains( Lops.VARIABLE_NAME_PLACEHOLDER)) {
				to   = Double.valueOf(s[6]);
	        }
			if (!s[7].contains( Lops.VARIABLE_NAME_PLACEHOLDER)) {
				incr = Double.valueOf(s[7]);
	        }
			
			CPOperand in = null;
			return new RandCPInstruction(op, method, in, out, rows, cols, rpb, cpb, from, to, incr, str);
		}
		else 
			throw new DMLRuntimeException("Unrecognized data generation method: " + method);
	}
	
	public void processInstruction (ExecutionContext ec)
		throws DMLRuntimeException
	{
		String output_name = output.get_name();
		MatrixBlock soresBlock = null;
		
		if ( this.method == DataGenMethod.RAND ) {
			//generate pseudo-random seed (because not specified) 
			long lSeed = seed; //seed per invocation
			if( lSeed == DataGenOp.UNSPECIFIED_SEED ) 
				lSeed = DataGenOp.generateRandomSeed();
			
			LOG.trace("Process RandCPInstruction with seed = "+lSeed+".");
			
			//long begin = System.nanoTime();
			
			// setup seeds
			Well1024a bigrand = setupSeedsForRand(seed);
			
			// execute rand
			//soresBlock = (MatrixBlock) (MatrixBlock.randOperations((int)rows, (int)cols, rowsInBlock, colsInBlock, sparsity, minValue, maxValue, pdf, bigrand));
			soresBlock = (MatrixBlock) (MatrixBlock.randOperationsOLD((int)rows, (int)cols, sparsity, minValue, maxValue, pdf, seed));
			
			//System.out.println("RandTime " + (System.nanoTime()-begin)*1e-6 + " msec.");
		}
		else if ( this.method == DataGenMethod.SEQ ) {
			// (int)rows, (int)cols, rowsInBlock, colsInBlock, 
			soresBlock = (MatrixBlock) (MatrixBlock.seqOperations(seq_from, seq_to, seq_incr));
		}
		ec.setMatrixOutput(output_name, soresBlock);
	}
}
