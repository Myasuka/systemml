

solve = externalFunction(Matrix[Double] a, Matrix[Double] b)  return(Matrix[Double] c)
  implemented in (classname="com.ibm.bi.dml.packagesupport.LinearSolverWrapperCP",exectype="mem")   


#C = 2; 
alpha = 0.01
beta = 0.5
tol = 0.0001
regul_const = $4 #as.double(args[4])
maxiter = 100

# read (training and test) data files -- should be in matrix market format. see data.mtx 
X_nobias = read($1); # readMM(args[1]);

N = nrow(X_nobias)
#D = ncol(X_nobias)
newD = 250 #D+1

# read weights
#-- skip # y_bool = (y_arr==1)
#-- skip # C_arr = ifelse(y_bool, 1, num_pos/num_neg)
#C = matrix(C_arr, N, 1)
C = Rand(rows=N, cols=1, min=1, max=1); #matrix(1, N, 1)

X = Rand(rows=N, cols=newD, min=0, max=0); #Matrix(0, N, newD)
X[,1] = C
X[,2:newD] = X_nobias
D = 250 #newD

C = regul_const * C


# read (training and test) labels
y = read($2); #readMM(args[2]);

#y_arr = c(as.matrix(y))
#num_pos = length(which(y_arr==1))
#num_neg = length(which(y_arr==-1))

num_pos = ppred(y, 1.0, "==")
num_neg = ppred(y, -1.0, "==")


# initialize w
w = Rand(rows=D, cols=1, min=0, max=0); #matrix(0,D,1)
o = X %*% w
logistic = 1.0/(1.0 + exp(-y*o))
 
# number of iterations
iter = 0

converge = false

Id_vec = Rand(rows=D, cols=1, min=1, max=1); 
Id = diag(Id_vec) #Diagonal(D)

tX = t(X);

while(!converge) {

        logistic = 1.0/(1.0 + exp(-y*o))
        obj = castAsScalar(0.5 * t(w) %*% w + sum(-C*log(logistic)))
        grad = w + tX %*% (C*(logistic - 1)*y)
        logisticD = logistic*(1-logistic)
        norm_grad = sqrt(sum(grad*grad))
        d = C*logisticD
        #DD=Matrix(Diagonal(x=as.vector(d)))
	DD = diag(d);
        hessian = tX %*% (DD %*% X) + Id

        neg_grad = -grad;
	newton = solve(hessian, neg_grad)
        #newton = -grad
        n = X %*% newton
        s = t(grad) %*% newton
        tt = 1
        wnew = w + newton
        onew = o + n
	

        #while(as.matrix(0.5*t(wnew) %*% wnew + sum(C*log((1.0 + exp(-y*onew)))))  > as.matrix(obj + alpha*tt*s)) {
        #        tt = beta*tt;
        #        wnew = w + tt*newton
        #        onew = o + tt*n
        #}

	continue = true;
	inner = 0;
	while(continue) {
		temp_lhs = castAsScalar(0.5*t(wnew) %*% wnew + sum(C*log((1.0 + exp(-y*onew)))));
		temp_rhs = castAsScalar(obj + alpha*tt*s);
		if (temp_lhs > temp_rhs) {
			tt = beta*tt;
			wnew = w + tt*newton;
			onew = o + tt*n;
		}
		else {
			continue = false;
		}
		inner = inner + 1;
		print("Inner = " + inner);
	}

        w = wnew
        o = onew 
        iter = iter + 1
        converge = (norm_grad < tol) | (iter>maxiter)

        print("Iter=" + iter)
        print("Obj=" + obj)
        print("GradNorm=" + norm_grad)
        print("Converge=" + converge)
}

print("DONE " + iter);
write(w, $3);
#writeMM(as(w,"CsparseMatrix"), args[3], format = "text")
