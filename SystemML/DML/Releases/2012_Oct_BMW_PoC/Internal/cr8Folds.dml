################################################################################
#
# IBM Confidential
#
# OCO Source Materials
#
# (C) Copyright IBM Corp. 2009, 2010, 2011
#
# The source code for this program is not published or
#
# otherwise divested of its trade secrets, irrespective of
#
# what has been deposited with the U.S. Copyright Office.
#
################################################################################

#
# Given an input matrix M, produce a matrix for each fold: MF1, MF2, MF3, and MF4 
#

M = read( $1 + ".mtx");
n = nrow( M);
m = ncol( M);

# create a random vector and round to produce a vector with number 1, 2, 3, and 4

R = Rand (rows=n, cols = 1, min = 0.5, max = 4.5, pdf = "uniform");
R = round(R);

# produce 4 0/1 vectors using ppred (applying '==' on each cell in matrix
# comparing to 1, 2, 3, or 4)

RF1 = ppred( R, 1, "==");
RF2 = ppred( R, 2, "==");
RF3 = ppred( R, 3, "==");
RF4 = ppred( R, 4, "==");

# initialize 4 output matrixes, one for each Fold

F1 = Rand (rows=n, cols = m, min = 0, max = 0, pdf = "uniform");
F2 = Rand (rows=n, cols = m, min = 0, max = 0, pdf = "uniform");
F3 = Rand (rows=n, cols = m, min = 0, max = 0, pdf = "uniform");
F4 = Rand (rows=n, cols = m, min = 0, max = 0, pdf = "uniform");

# in parallel for each row, either copy each cell in a row or set to 0 in result.

parfor ( i in 1:m) {
  print("folds generation at iteration "+i);
  Mi = M[ ,i];
  F1[, i] = Mi * RF1;    
  F2[, i] = Mi * RF2;    
  F3[, i] = Mi * RF3;    
  F4[, i] = Mi * RF4;    
}

# write out matrices

write(  F1, $1 + "F1.mtx", format = "binary");
write(  F2, $1 + "F2.mtx", format = "binary");
write(  F3, $1 + "F3.mtx", format = "binary");
write(  F4, $1 + "F4.mtx", format = "binary");



