
\noindent {\bf Program Analysis:}
We now describe the sequence of steps a \dmlr\ script goes through to generate a parsed 
representation. Figure~\ref{fig:programanalysis} shows the result of program analysis for 
Script~\ref{scpt:gnmf}.

{\it Type Assignment}: The first step is to assign data types to
each variable in the \dmlr\ script. For instance, \concept{ReadMM}
statements (Steps~1-3) are used to type V, W and H as matrices, while \concept{Assignment} 
statements (Steps~4-5) are used to identify $max\_iteration$ and $i$ as scalar variables. 
%This information is then propagated through the rest of the program.

{\it Statement Block Identification}: As control constructs (such as \concept{while}) and 
\concept{functions} break the sequential flow of a \dmlr\ program, they naturally divide 
the program into \textit{statement blocks}. Each statement block consists of consecutive 
\concept{Assignment}, \concept{ReadMM} and \concept{WriteMM} statements, as the operations 
involved in these statements can be collectively optimized. 
Figure~\ref{fig:programanalysis} illustrates our example algorithm broken down into three 
statement blocks ($SB_1, SB_2$ and $SB_3$).

%\item {\it Live Variable Analysis}. Notice how variables may be
%updated-in-place in a \dmlr\ program. E.g., in Step~8, the variable W
%is both read and written in the same statement. Since this statement
%appears within a \concept{while} loop, W may either refer to the
%output of Step~2 (for the first iteration) or Step~8 in the previous
%iteration (for subsequent iterations). Furthermore, we need to decide
%what variables need to be passed across statement blocks. Therefore,
%we perform live-variable analysis~\footnote{This is similar to the
%classic data flow analysis typically performed by compilers in
%programming languages} on the program to connect each variable use
%with the previous write for that variable. For each statement block,
%we also identify the variables that will be required from previous
%statement blocks ({\it Live Variables In}) and the variables that will
%be output by the current statement block ({\it Live Variables
%Out}). The results of live variable analysis are shown in
%Figure~\ref{fig:programanalysis}.

{\it Live Variable Analysis}: The goal of this step is twofold:
(a)~Connect each variable use with the immediately preceding write(s)
for that variable across different evaluation paths. For example,
variable W used in Step~7 refers to the output of Step~2 for the
first iteration of the loop and Step~8 for second iteration onwards. (b)~For each statement block, identify the variables that will be required from previous
statement blocks ({\it Live Variables In}) and the variables that will
be output by the current statement block ({\it Live Variables Out}). 
The results of live variable analysis are shown in Figure~\ref{fig:programanalysis}.


