# Arguments
# 1st arg: X (one column time series)
# 2nd arg: p (non-seasonal AR order)
# 3rd arg: d (non-seasonal differencing order)
# 4th arg: q (non-seasonal MA order)
# 5th arg: P (seasonal AR order)
# 6th arg: D (seasonal differencing order)
# 7th arg: Q (seasonal MA order)
# 8th arg: s (period in terms of number of time-steps)
# 9th arg: 0/1 (1 means include.mean)
# 10th arg: file name to store learnt parameters

arima_css = function(Matrix[Double] w, Matrix[Double] X, Integer p, Integer P, Integer q, Integer Q, Integer s, Integer include_mean) return (Double obj){
	b = X[,2:ncol(X)]%*%w
	
	R = Rand(rows=nrow(X), cols=nrow(X), min=0, max=0)
	for(i7 in 1:q){
		ma_ind_ns = include_mean+P*p+P+p+i7
		err_ind_ns = i7
		ones_ns = Rand(rows=nrow(R)-err_ind_ns, cols=1, min=1, max=1)
		d_ns = ones_ns * castAsScalar(w[ma_ind_ns,1])
		R[1+err_ind_ns:nrow(R),1:ncol(R)-err_ind_ns] = R[1+err_ind_ns:nrow(R),1:ncol(R)-err_ind_ns] + diag(d_ns)
	}
	for(i8 in 1:Q){
		for(i9 in 0:q){
			ma_ind_s = include_mean+P*p+P+p+q+(i8-1)*(q+1)+i9+1
			err_ind_s = s*i8 + i9
			ones_s = Rand(rows=nrow(R)-err_ind_s, cols=1, min=1, max=1)
			d_s = ones_s * castAsScalar(w[ma_ind_s,1])
			R[1+err_ind_s:nrow(R),1:ncol(R)-err_ind_s] = R[1+err_ind_s:nrow(R),1:ncol(R)-err_ind_s] + diag(d_s)
		}
	}
	
	max_iter = 100
	tol = 0.01

	y_hat = Rand(rows=nrow(X), cols=1, min=0, max=0)
	iter = 0
  	diff = tol+1.0
	while(iter < max_iter & diff > tol){
    	y_hat_new = b - R%*%y_hat
    	diff = sum((y_hat_new-y_hat)*(y_hat_new-y_hat))
    	y_hat = y_hat_new
    	iter = iter + 1

    	#print("Inner iter " + iter + ": " + diff)
  	}
  	print("Inner loop " + iter + ": " + diff)
  
  	errs = X[,1] - y_hat
  	obj = sum(errs*errs)
}

#input col of time series data
X = read($1)

#non-seasonal order
p = $2
d = $3
q = $4

#seasonal order
P = $5
D = $6
Q = $7

#length of the season
s = $8

include_mean = $9

num_rows = nrow(X)

if(num_rows <= d){
	print("non-seasonal differencing order should be larger than length of the time-series")
}

Y = X
for(i in 1:d){
	n1 = nrow(Y)+0.0
	Y = Y[2:n1,] - Y[1:n1-1,]
}

num_rows = nrow(Y)+0.0
if(num_rows <= s*D){
	print("seasonal differencing order should be larger than number of observations divided by length of season")
}

for(i in 1:D){
	n1 = nrow(Y)+0.0
	Y = Y[s+1:n1,] - Y[1:n1-s,]
}

n = nrow(Y)

max_ar_col = s*P+p
max_ma_col = s*Q+q
if(max_ar_col > max_ma_col){
	max_arma_col = max_ar_col
}else{
	max_arma_col = max_ma_col
}

totcols = 1+include_mean+P*p+P+p+Q*q+Q+q #target col (X), p-P cols, q-Q cols  

Z = Rand(rows=n, cols=totcols, min=0, max=0)
Z[,1] = Y #target col
if(include_mean == 1){
	constant_col = Rand(rows=n, cols=1, min=1, max=1)
	Z[,1+include_mean] = constant_col
}

parfor(i1 in 1:p, check=0){
	Z[i1+1:n,1+include_mean+i1] = Y[1:n-i1,]
}
parfor(i2 in 1:P){
	parfor(j1 in 0:p, check=0){
		Z[s*i2+j1+1:n,1+include_mean+p+(i2-1)*(p+1)+j1+1] = Y[1:n-s*i2-j1,]
	}
}
parfor(i5 in 1:q, check=0){
	Z[i5+1:n,1+include_mean+P*p+P+p+i5] = Y[1:n-i5,]
}
parfor(i6 in 1:Q){
	parfor(j2 in 0:q, check=0){
		Z[s*i6+j2+1:n,1+include_mean+P*p+P+p+q+(i6-1)*(q+1)+j2+1] = Y[1:n-s*i6-j2,]
	}
}

one = Rand(rows=1, cols=1, min=1, max=1)

simplex = Rand(rows=totcols-1, cols=totcols, min=0, max=0)
point = Rand(rows=totcols-1, cols=1, min=0, max=0)
for(i in 2:ncol(simplex)){
	point[i-1,1] = point[i-1,1] + 1
	simplex[,i] = point
}
objvals = Rand(rows=1, cols=ncol(simplex), min=0, max=0)
for(i3 in 1:ncol(simplex)){
#parfor(i3 in 1:ncol(simplex)){
	arima_css_objval = arima_css(simplex[,i3], Z, p, P, q, Q, s, include_mean)
	objvals[1,i3] = arima_css_objval*one
}

#make these top level params?
max_iter = 1000
tol = 0.001

best_index = 1
iter = 0
diff = tol+1.0
while(diff > tol & iter < max_iter) {
	best_index = 1
	worst_index = 1
	for(i in 2:ncol(objvals)){
		this = castAsScalar(objvals[1,i])
		that = castAsScalar(objvals[1,best_index])
  		if(that > this){
    		best_index = i
  		}
  		that = castAsScalar(objvals[1,worst_index])
  		if(that < this){
    		worst_index = i
  		}
	}
	second_worst_index = best_index
	for(i in 1:ncol(objvals)){
		this = castAsScalar(objvals[1,i])
		that = castAsScalar(objvals[1,second_worst_index])
  		if(i != worst_index & that < this){
    		second_worst_index = i
  		}
	}
	
	best_val = castAsScalar(objvals[1,best_index])
	worst_val = castAsScalar(objvals[1,worst_index])
	second_worst_val = castAsScalar(objvals[1,second_worst_index])
	
	obj = castAsScalar(objvals[1,best_index])
	print("OBJ: " + obj)
	
	mx = rowMaxs(simplex)
	mn = rowMins(simplex)
	diff = sum((mx-mn)*(mx-mn))
	print("Outer Iter " + iter + ": " + diff)
	
	c = (rowSums(simplex) - simplex[,worst_index])/(nrow(simplex))
	x_r = 2*c - simplex[,worst_index]
	obj_x_r = arima_css(x_r, Z, p, P, q, Q, s, include_mean)
	
	if(best_val <= obj_x_r & obj_x_r < second_worst_val){
		simplex[,worst_index] = x_r
		objvals[1,worst_index] = obj_x_r
	}else{
		if(obj_x_r < best_val){
			x_e = 2*x_r - c
			obj_x_e = arima_css(x_e, Z, p, P, q, Q, s, include_mean)
			
			if(obj_x_r <= obj_x_e){
				simplex[,worst_index] = x_r
				objvals[1,worst_index] = obj_x_r
			}else{
				simplex[,worst_index] = x_e
				objvals[1,worst_index] = obj_x_e
			}
		}else{
			performShrink = 0
			
			if(obj_x_r < worst_val){
				x_c_out = (x_r + c)/2
				obj_x_c_out = arima_css(x_c_out, Z, p, P, q, Q, s, include_mean)
				
				if(obj_x_c_out < obj_x_r){
					simplex[,worst_index] = x_c_out
					objvals[1,worst_index] = obj_x_c_out
				}else{
					performShrink = 1
				}
			}else{
				x_c_in = (simplex[,worst_index] + c)/2
				obj_x_c_in = arima_css(x_c_in, Z, p, P, q, Q, s, include_mean)
				
				if(obj_x_c_in < worst_val){
					simplex[,worst_index] = x_c_in
					objvals[1,worst_index] = obj_x_c_in
				}else{
					performShrink = 1
				}
			}
			
			if(performShrink == 1){
				best_point = simplex[,best_index]
				parfor(i4 in 1:ncol(simplex)){
					simplex[,i4] = (simplex[,i4] + best_point)/2
					objvals[1,i4] = arima_css(simplex[,i4], Z, p, P, q, Q, s, include_mean)
				}
			}
		}
	}
	
	iter = iter + 1
}

best_point = simplex[,best_index]
write(best_point, $10, format="text")
