# Performs a contingency table analysis over specified columns of the input matrix
# Computes 95% confidence intervals for binomial ratios using both Wilson and Exact Scores
# INPUT 1: Matrix [rows, cols] of records (rows) with some categorical attributes (columns)
# INPUT 2: The number of records
# INPUT 3: The number of features, i.e. input columns
# IMPUT 4: Index of the partition column, e.g. US_State (must be categorical feature)
# INPUT 5: Index of the category column, e.g. is_customer or is_AA (must be categorical feature)
# INPUT 6: Index of the value column, e.g. buzz or sentiment (must be categorical feature)
# INPUT 7: The output file path/name
# OUTPUT : 
#   Column  1: Partition index
#   Column  2: Number of all records
#   Column  3: 



Matrix [rows, 21] of doubles, containing the following information:
#     (m / sum(m), Wilson 95%-conf.left, Wilson 95%-conf.right, ...
#      n / sum(n), Wilson 95%-conf.left, Wilson 95%-conf.right, ...
#      m / n,      Wilson 95%-conf.left, Wilson 95%-conf.right, ...)
# PLEASE BE AWARE THAT FOR EXTREMELY SMALL COUNTS THE INTERVALS WILL BE WRONG! THEY USE GAUSSIAN APPROXIMATION!
# EXAMPLE: wilson_score.dml -args "test/scripts/applications/glmReg/wilson_test_input.mtx" 7 "test/scripts/applications/glmReg/wilson_test_output.mtx"



print ("BEGIN CTABLE ANALYSIS SCRIPT");
print ("Reading the Input Matrix...");
InMtx = read ($1, rows = $2, cols = $3, format = "text");

print ("Preparing to compute the contingency tables...");
num_records = $2;
num_features = $3;
idx_partition = $4;
idx_category = $5;
idx_value = $6;
raw_prt_vector = InMtx [, idx_partition];
raw_ctg_vector = InMtx [, idx_category];
raw_val_vector = InMtx [, idx_value];

min_prt = min (raw_prt_vector);
max_prt = max (raw_prt_vector);
min_ctg = min (raw_ctg_vector);
max_ctg = max (raw_ctg_vector);
min_val = min (raw_val_vector);
max_val = max (raw_val_vector);
num_prt = max_prt - min_prt + 1;  #  In the future, eliminate all non-occurring indices
num_ctg = max_ctg - min_ctg + 1;
num_val = max_val - min_val + 1;
shift_prt_vector = raw_prt_vector - min_prt + 1;
shift_ctg_vector = raw_ctg_vector - min_ctg + 1;
shift_val_vector = raw_val_vector - min_val + 1;
combo_vector = (prt_vector - min_prt) * num_ctg + (ctg_vector - min_ctg) + 1;

print ("Computing the contingency tables...");
ctable_prt_ctg = ctable (shift_prt_vector, shift_ctg_vector);
ctable_prt_val = ctable (shift_prt_vector, shift_val_vector);
ctable_ctg_val = ctable (shift_ctg_vector, shift_val_vector);
ctable_combo_val = ctable (combo_vector, shift_val_vector);

# ctable_combo_val is a column-vector of  num_prt  contingency tables, one table per partition
# Each contingency table has size:  num_ctg x num_val
# The cell that corresponds to (partition, category, value) = (prt, ctg, val) has coordinates [i, j]
# where i = (prt - min_prt) * num_ctg + (ctg - min_ctg) + 1, and j = val - min_val + 1

print ("Computing partition vs. category binomial statistics, ignoring the value...");

sums_prt = rowSums (ctable_prt_ctg);
sums_ctg = t(colSums (ctable_prt_ctg));
sum_of_all = sum (sums_prt);

# All everywhere vs. in a partition

dummy_prt_vector = Rand (rows = num_prt, cols = 1, min = 1.0, max = 1.0);
sum_of_all_as_prt_vector = dummy_prt_vector * sum_of_all;
[p_all_vs_prt, wilson_left_all_vs_prt, wilson_right_all_vs_prt] = wilson_confidence (sum_of_all_as_prt_vector, sums_prt);

# All everywhere vs. in a category

dummy_ctg_vector = Rand (rows = num_ctg, cols = 1, min = 1.0, max = 1.0);
sum_of_all_as_ctg_vector = dummy_ctg_vector * sum_of_all;
[p_all_vs_ctg, wilson_left_all_vs_ctg, wilson_right_all_vs_ctg] = wilson_confidence (sum_of_all_as_ctg_vector, sums_ctg);

# All in a partition vs. a category in the partition

sums_prt_as_ctg_matrix = sums_prt %*% t(dummy_ctg_vector);
[p_prt_vs_prt_ctg, wilson_left_prt_vs_prt_ctg, wilson_right_prt_vs_prt_ctg] = wilson_confidence (sums_prt_as_ctg_matrix, ctable_prt_ctg);

print ("Computing partition vs. value and category vs. value binomial statistics...");

# All everywhere vs. value everywhere

sums_val = t(colSums (ctable_prt_val));
dummy_val_vector = Rand (rows = num_val, cols = 1, min = 1.0, max = 1.0);
sum_of_all_as_val_vector = dummy_val_vector * sum_of_all;
[p_all_vs_val, wilson_left_all_vs_val, wilson_right_all_vs_val] = wilson_confidence (sum_of_all_as_val_vector, sums_val);

# All in a partition vs. value in the partition

sums_prt_as_val_matrix = sums_prt %*% t(dummy_val_vector);
[p_prt_vs_prt_val, wilson_left_prt_vs_prt_val, wilson_right_prt_vs_prt_val] = wilson_confidence (sums_prt_as_val_matrix, ctable_prt_val);

# All in a category vs. value in the category

sums_ctg_as_val_matrix = sums_ctg %*% t(dummy_val_vector);
[p_ctg_vs_ctg_val, wilson_left_ctg_vs_ctg_val, wilson_right_ctg_vs_ctg_val] = wilson_confidence (sums_ctg_as_val_matrix, ctable_ctg_val);

print ("Computing partition & category vs. value binomial statistics...");

# All in a partition & category vs. value in the partition & category

sums_combo = rowSums (ctable_combo_val);
sums_combo_as_val_matrix = sums_combo %*% t(dummy_val_vector);
wilson_confidence (sums_combo_as_val_matrix, ctable_combo_val);

# ODDS RATIOS ...








# print ("Writing the contingency table...");
# write (F, $3, format = "text");

print ("END CTABLE ANALYSIS SCRIPT");



/*

M = X [, 1];
N = X [, 2];
blahh = Rand (rows = num_rows, cols = 1, min = 1.0, max = 1.0);
sum_M = blahh * sum(M);
sum_N = blahh * sum(N);

[p_m_sum, l_m_sum, r_m_sum] = compute_confidence (sum_M, M);
[p_n_sum, l_n_sum, r_n_sum] = compute_confidence (sum_N, N);
[p_m_n, l_m_n, r_m_n] = compute_confidence (N, M);

M_minus_1 = M - 1;
N_minus_1 = N - 1;
big_alpha   = 0.975 * blahh;
small_alpha = 0.025 * blahh;

[l_m_sum_exact_narrow] = binomQuantile (sum_M, M, big_alpha);
[r_m_sum_exact_narrow] = binomQuantile (sum_M, M_minus_1, small_alpha);
[l_m_sum_exact_wide]   = binomQuantile (sum_M, M_minus_1, big_alpha);
[r_m_sum_exact_wide]   = binomQuantile (sum_M, M, small_alpha);

[l_n_sum_exact_narrow] = binomQuantile (sum_N, N, big_alpha);
[r_n_sum_exact_narrow] = binomQuantile (sum_N, N_minus_1, small_alpha);
[l_n_sum_exact_wide]   = binomQuantile (sum_N, N_minus_1, big_alpha);
[r_n_sum_exact_wide]   = binomQuantile (sum_N, N, small_alpha);

[l_m_n_exact_narrow]   = binomQuantile (N, M, big_alpha);
[r_m_n_exact_narrow]   = binomQuantile (N, M_minus_1, small_alpha);
[l_m_n_exact_wide]     = binomQuantile (N, M_minus_1, big_alpha);
[r_m_n_exact_wide]     = binomQuantile (N, M, small_alpha);

result = Rand (rows = num_rows, cols = 21, min = 0.0, max = 0.0);
result [,  1] = p_m_sum;
result [,  2] = l_m_sum;
result [,  3] = r_m_sum;
result [,  4] = l_m_sum_exact_narrow;
result [,  5] = r_m_sum_exact_narrow;
result [,  6] = l_m_sum_exact_wide;
result [,  7] = r_m_sum_exact_wide;

result [,  8] = p_n_sum;
result [,  9] = l_n_sum;
result [, 10] = r_n_sum;
result [, 11] = l_n_sum_exact_narrow;
result [, 12] = r_n_sum_exact_narrow;
result [, 13] = l_n_sum_exact_wide;
result [, 14] = r_n_sum_exact_wide;

result [, 15] = p_m_n;
result [, 16] = l_m_n;
result [, 17] = r_m_n;
result [, 18] = l_m_n_exact_narrow;
result [, 19] = r_m_n_exact_narrow;
result [, 20] = l_m_n_exact_wide;
result [, 21] = r_m_n_exact_wide;

print ("M / sum(M)  RESULTS:  Wilson, Exact Narrow, Exact Wide");

for (i in 1:num_rows) {
    p1  = castAsScalar (round (result [i,  1] * 100000) / 1000);
    l1  = castAsScalar (round (result [i,  2] * 100000) / 1000);
    r1  = castAsScalar (round (result [i,  3] * 100000) / 1000);
    ln1 = castAsScalar (round (result [i,  4] * 100000) / 1000);
    rn1 = castAsScalar (round (result [i,  5] * 100000) / 1000);
    lw1 = castAsScalar (round (result [i,  6] * 100000) / 1000);
    rw1 = castAsScalar (round (result [i,  7] * 100000) / 1000);

    if (ln1 <= rn1) {
        print ("Row " + i + ":   "
            + castAsScalar (M [i, 1]) + "/" + castAsScalar (sum_M [i, 1]) + " = " 
            + p1 + "%  [" + l1 + "%, " + r1 + "%]   [" + ln1 + "%, " + rn1 + "%]   [" + lw1 + "%, " + rw1 + "%]");
    } else {
        print ("Row " + i + ":   "
            + castAsScalar (M [i, 1]) + "/" + castAsScalar (sum_M [i, 1]) + " = " 
            + p1 + "%  [" + l1 + "%, " + r1 + "%]   [Not Applicable]   [" + lw1 + "%, " + rw1 + "%]");
    }
}

print ("N / sum(N)  RESULTS:  Wilson, Exact Narrow, Exact Wide");

for (i in 1:num_rows) {
    p2  = castAsScalar (round (result [i,  8] * 100000) / 1000);
    l2  = castAsScalar (round (result [i,  9] * 100000) / 1000);
    r2  = castAsScalar (round (result [i, 10] * 100000) / 1000);
    ln2 = castAsScalar (round (result [i, 11] * 100000) / 1000);
    rn2 = castAsScalar (round (result [i, 12] * 100000) / 1000);
    lw2 = castAsScalar (round (result [i, 13] * 100000) / 1000);
    rw2 = castAsScalar (round (result [i, 14] * 100000) / 1000);

    if (ln2 <= rn2) {
        print ("Row " + i + ":   "
            + castAsScalar (N [i, 1]) + "/" + castAsScalar (sum_N [i, 1]) + " = " 
            + p2 + "%  [" + l2 + "%, " + r2 + "%]   [" + ln2 + "%, " + rn2 + "%]   [" + lw2 + "%, " + rw2 + "%]   ");
    } else {
        print ("Row " + i + ":   "
            + castAsScalar (N [i, 1]) + "/" + castAsScalar (sum_N [i, 1]) + " = " 
            + p2 + "%  [" + l2 + "%, " + r2 + "%]   [Not Applicable]   [" + lw2 + "%, " + rw2 + "%]   ");
    }
}

print ("M / N  RESULTS:  Wilson, Exact Narrow, Exact Wide");

for (i in 1:num_rows) {
    p3  = castAsScalar (round (result [i, 15] * 100000) / 1000);
    l3  = castAsScalar (round (result [i, 16] * 100000) / 1000);
    r3  = castAsScalar (round (result [i, 17] * 100000) / 1000);
    ln3 = castAsScalar (round (result [i, 18] * 100000) / 1000);
    rn3 = castAsScalar (round (result [i, 19] * 100000) / 1000);
    lw3 = castAsScalar (round (result [i, 20] * 100000) / 1000);
    rw3 = castAsScalar (round (result [i, 21] * 100000) / 1000);

    if (ln3 <= rn3) {
        print ("Row " + i + ":   "
            + castAsScalar (M [i, 1]) + "/" + castAsScalar (    N [i, 1]) + " = " 
            + p3 + "%  [" + l3 + "%, " + r3 + "%]   [" + ln3 + "%, " + rn3 + "%]   [" + lw3 + "%, " + rw3 + "%]   ");
    } else {
        print ("Row " + i + ":   "
            + castAsScalar (M [i, 1]) + "/" + castAsScalar (    N [i, 1]) + " = " 
            + p3 + "%  [" + l3 + "%, " + r3 + "%]   [Not Applicable]   [" + lw3 + "%, " + rw3 + "%]   ");
    }
}



print ("Writing the results...");
write (result, $3, format = "text");
print ("END WILSON SCORE SCRIPT");

*/

wilson_confidence = function (matrix[double] n, matrix[double] m)
return (matrix[double] ratio, matrix[double] conf_left, matrix[double] conf_right)
{
    z = 1.96;      # 97.5% normal percentile, for 95% confidence interval
    z_sq_n = z * z * n;
    qroot = sqrt (z_sq_n * (m * (n - m) + z_sq_n / 4));
    midpt = n * m + z_sq_n / 2;
    denom = n * n + z_sq_n;
    ratio = m / n;
    conf_left  = (midpt - qroot) / denom;
    conf_right = (midpt + qroot) / denom;
}
