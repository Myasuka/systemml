# THE SIMPLE LEAST SQUARES PROCEDURE SCRIPT:
get_simpleLS_point =
    function (Matrix[double] A_simpleLS, Matrix[double] g_simpleLS, double lambda_simpleLS, int num_features_simpleLS)
    return (Matrix[double] z_simpleLS)
{
    eps_simpleLS = 0.0;
    z_simpleLS = Rand (rows = num_features_simpleLS, cols = 1, min = 0, max = 0);
    r_simpleLS = g_simpleLS;
    p_simpleLS = -r_simpleLS;
    norm_r2_simpleLS = sum(r_simpleLS * r_simpleLS);

    max_iteration_simpleLS = num_features_simpleLS;
    i_simpleLS = 0;
    while(i_simpleLS < max_iteration_simpleLS & max(abs(r_simpleLS)) >= eps_simpleLS)
    {
        q_simpleLS = (A_simpleLS %*% p_simpleLS) + lambda_simpleLS * p_simpleLS;
        alpha_simpleLS = norm_r2_simpleLS / castAsScalar(t(p_simpleLS) %*% q_simpleLS);
        z_simpleLS = z_simpleLS + alpha_simpleLS * p_simpleLS;
        old_norm_r2_simpleLS = norm_r2_simpleLS;
        r_simpleLS = r_simpleLS + alpha_simpleLS * q_simpleLS;
        norm_r2_simpleLS = sum(r_simpleLS * r_simpleLS);
        p_simpleLS = -r_simpleLS + (norm_r2_simpleLS / old_norm_r2_simpleLS) * p_simpleLS;
        i_simpleLS = i_simpleLS + 1;
    }
}

# Shifts and scales the weights to ensure the desired statistics for Linear Form = w^T X
# Used in data and/or weight generation in the testing of GLM, Logistic Regression etc.
# new_sigmaLF == sigmaLF if successful, new_sigmaLF > sigmaLF if had to relax this constraint
scaleWeights = 
    function (Matrix[double] X_data, Matrix[double] w_unscaled, double meanLF, double sigmaLF)
    return (Matrix[double] w_scaled, double new_sigmaLF)
{
    numFeatures = nrow (w_unscaled);
    W_ext = Rand (rows = numFeatures, cols = 2, min = 1, max = 1);
    W_ext [, 1] = w_unscaled;
    S1 = colSums (X_data %*% W_ext);
    TF = Rand (rows = 2, cols = 2, min = 1, max = 1);
    TF [1, 1] = S1 [1, 1] * meanLF * nrow (X_data) / castAsScalar (S1 %*% t(S1));
    TF [1, 2] = S1 [1, 2];
    TF [2, 1] = S1 [1, 2] * meanLF * nrow (X_data) / castAsScalar (S1 %*% t(S1));
    TF [2, 2] = - S1 [1, 1];
    TF = W_ext %*% TF;
    Q = t(TF) %*% t(X_data) %*% X_data %*% TF;
    Q [1, 1] = Q [1, 1] - nrow (X_data) * meanLF * meanLF;
    new_sigmaLF = sigmaLF;
    discr = castAsScalar (Q [1, 1] * Q [2, 2] - Q [1, 2] * Q [2, 1] - nrow (X_data) * Q [2, 2] * sigmaLF * sigmaLF);
    if (discr > 0.0) {
        new_sigmaLF = sqrt (castAsScalar ((Q [1, 1] * Q [2, 2] - Q [1, 2] * Q [2, 1]) / (nrow (X_data) * Q [2, 2])));
        discr = -0.0;
    }
    t = Rand (rows = 2, cols = 1, min = 1, max = 1);
    t [2, 1] = (- Q [1, 2] + sqrt (- discr)) / Q [2, 2];
    w_scaled = TF %*% t;
}

gaussian_probability = function (Matrix[double] vector_of_points)
    return (Matrix[double] vector_of_probabilities)
{
    t_gp = 1.0 / (1.0 + abs (vector_of_points) * 0.231641888);  # 0.231641888 = 0.3275911 / sqrt (2.0)
    erf_gp = 1.0 - t_gp * ( 0.254829592 
                 + t_gp * (-0.284496736 # "Handbook of Mathematical Functions", ed. by M. Abramowitz and I.A. Stegun,
                 + t_gp * ( 1.421413741 # U.S. Nat-l Bureau of Standards, 10th print (Dec 1972), Sec. 7.1.26, p. 299
                 + t_gp * (-1.453152027 
                 + t_gp *   1.061405429)))) * exp (- vector_of_points * vector_of_points / 2.0);
    erf_gp = erf_gp * 2.0 * (ppred (vector_of_points, 0.0, ">") - 0.5);
    vector_of_probabilities = 0.5 + 0.5 * erf_gp;
}

round_to_print = function (double x_to_truncate) return (double x_to_print)
{
    x_to_print = x_to_truncate;
    abs_x_to_truncate = abs (x_to_truncate);
    if (abs_x_to_truncate > 0.0)
    {
        dummy = Rand (rows = 1, cols = 1, min = 0, max = 0);
        unrounded_power_of_ten = -0.5 + log (abs_x_to_truncate) / log (10.0);
        power_of_ten = castAsScalar (round (unrounded_power_of_ten + dummy));
        abs_power_of_ten = abs (power_of_ten);
        x_to_round = x_to_truncate;
        while (abs_power_of_ten > 3.1) {
            abs_power_of_ten = abs_power_of_ten - 4.0;
            if (power_of_ten > 0.1) {
                x_to_round = x_to_round / 10000.0;
            }
            else {
                x_to_round = x_to_round * 10000.0;            
            }
        }
        x_to_print = castAsScalar (round ((x_to_round * 10000.0) + dummy));
        x_to_print = x_to_print / 10000.0;
        abs_power_of_ten = abs (power_of_ten);
        while (abs_power_of_ten > 3.1) {
            abs_power_of_ten = abs_power_of_ten - 4.0;
            if (power_of_ten > 0.1) {
                x_to_print = x_to_print * 10000.0;
            }
            else {
                x_to_print = x_to_print / 10000.0;            
            }
        }
    }
}
