#-------------------------------------------------------------
# IBM Confidential
# OCO Source Materials
# (C) Copyright IBM Corp. 2010, 2013
# The source code for this program is not published or
# otherwise divested of its trade secrets, irrespective of
# what has been deposited with the U.S. Copyright Office.
#-------------------------------------------------------------

# CHOLESKY FACTORIZATION PROCEDURE SCRIPT:
get_Cholesky =
    function (Matrix[double] A_Chol, double error_Chol)
    return (Matrix[double] G_Chol, Matrix[double] P_Chol, int r_Chol)
{
    G_Chol = A_Chol;
    sz_Chol = nrow (A_Chol);
    random_vector = Rand (rows = sz_Chol, cols = 1, min = 0.0, max = 1.0);
    mask = Rand (rows = sz_Chol, cols = 1, min = 1.0, max = 1.0);
    unity_matrix = diag (mask);
    P_Chol = unity_matrix;
    r_Chol = 1;
    end_Chol_loop = 0;
    while (r_Chol <= sz_Chol & end_Chol_loop == 0)
    {
        end_Chol_loop = 1;
        masked_diagonal = mask [, 1] * diag (G_Chol);
        largest_diagonal_element = max (masked_diagonal);
        
        if (largest_diagonal_element > error_Chol)
        {
            end_Chol_loop = 0;
            e_pivot_raw = random_vector * ppred (masked_diagonal, largest_diagonal_element, "==");
            e_pivot = ppred (e_pivot_raw, max (e_pivot_raw), "==");
            
            e_change = (P_Chol %*% e_pivot) - unity_matrix [, r_Chol];
            P_Chol = P_Chol - e_change %*% t(e_change) %*% P_Chol;

            pivot_vector = (mask / sqrt (largest_diagonal_element)) * (G_Chol %*% e_pivot);
            tmp_M = diag (pivot_vector) %*% (mask - e_pivot / 2.0) %*% t(e_pivot);
            G_Chol = G_Chol + tmp_M + t(tmp_M) - pivot_vector %*% t(pivot_vector);

            mask = mask - e_pivot;
            r_Chol = r_Chol + 1;
        }
    }
    r_Chol = r_Chol - 1;
    
    L = Rand (rows = sz_Chol, cols = sz_Chol, min = 0.0, max = 0.0);
    mask = Rand (rows = sz_Chol, cols = 1, min = 1.0, max = 1.0);
    zero_cell = Rand (rows = 1, cols = 1, min = 0.0, max = 0.0);
    for (i in 1:r_Chol)
    {
        L [, i] = mask;
        mask [i, 1] = zero_cell;
    }
    G_Chol = L * (P_Chol %*% G_Chol %*% t(P_Chol));
}

