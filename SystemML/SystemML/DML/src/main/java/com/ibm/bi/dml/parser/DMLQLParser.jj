/**
 * IBM Confidential
 * OCO Source Materials
 * (C) Copyright IBM Corp. 2010, 2014
 * The source code for this program is not published or otherwise divested of its trade secrets, irrespective of what has been deposited with the U.S. Copyright Office.
 */

// Parser for DML QL files

options { 
	STATIC = false;
	// JDK_VERSION = "5.0";
 	DEBUG_PARSER = false;
 	DEBUG_TOKEN_MANAGER = false;
 	UNICODE_INPUT = true;
 	//COMMON_TOKEN_ACTION = true;
 	ERROR_REPORTING = true;
}

PARSER_BEGIN(DMLQLParser)

package com.ibm.bi.dml.parser;

import java.io.*;
import java.util.*; 
import java.util.regex.*;
import com.ibm.bi.dml.parser.Expression.DataType;
import com.ibm.bi.dml.parser.Expression.ValueType;
import com.ibm.bi.dml.parser.Expression.FormatType;
import com.ibm.bi.dml.parser.Expression.BinaryOp;
import com.ibm.bi.dml.parser.Expression.DataOp;
import com.ibm.bi.dml.parser.LanguageException;
import com.ibm.bi.dml.parser.DMLParseException;
import java.util.ArrayList;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;



/**
 * Main entry point for the DML QL file parser.
 * 
 * NOTE: This class is GENERATED from DMLQLParser.jj!!!
 */
public class DMLQLParser extends DMLQLParserBase{

	protected static final Log LOG = LogFactory.getLog(DMLQLParser.class.getName());

	/** stores the listing of command-line arguments, which are indexed from 1 and being with '$' --  $1, $2, etc. **/
 	private HashMap<String,String> commandArgs; 

	/** stores working directory to DML packages (directory to look for source files) **/
 	private String dmlWorkingDir = ".";

 	private String _filename = "MAIN SCRIPT";

	public String getFilename() {
		return _filename;
	}
	
	public void setFilename(String fname){
		_filename = fname;
	}	  

 	/** Convenience constructor for reading from a string. */
 	public DMLQLParser(String s)throws IOException, ParseException {
  		this(new StringReader(s));
 	}
 
	/** Convenience constructor for reading from a string. */
	public DMLQLParser(String s2, String encoding, HashMap<String,String> commandArgs)throws IOException, ParseException {
	
		this(new BufferedReader(new StringReader(s2)));
		setFileEncoding(encoding);
	    setCommandArgs(commandArgs);
	        
	  	// initialize working dir to current working directory
	  	dmlWorkingDir = new String(".");
	}

 	public DMLQLParser(File f, String encoding, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(new BufferedReader(new InputStreamReader(new FileInputStream(f), encoding)));         
		setFileEncoding(encoding);
		setCommandArgs(commandArgs);
		      
		// initialize working dir to current working directory
		dmlWorkingDir = new String(".");
		setFilename(f.getName());
	}

	private void setCommandArgs(HashMap<String,String> ca){
		commandArgs = ca;
	}

	private String printErrorLocation(int line, int col){
		return "ERROR: " + _filename + " -- line " + line + ", col " + col + " -- "; 
	}

	private String printWarningLocation(int line, int col){		
		return "WARNING: " + _filename + " -- line " + line + ", col " + col + " -- "; 
	}	  
   
	public DMLQLParser(File f, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(f, DEFAULT_ENCODING, commandArgs);
	}

	public DMLQLParser(String s2, HashMap<String,String> commandArgs)throws IOException, ParseException {
		this(s2, DEFAULT_ENCODING, commandArgs);
	}

	public static final String LANG_JAVA = "Java";

	private String getTokenInfo(Token t){
		if (t == null)
			return ""; 
		else
			return "(" + t.toString() + " in line " + t.beginLine + ", column " + t.beginColumn + ")";
	}
	
}  // end class DMLQLParser

PARSER_END(DMLQLParser)

///////////////////////////////////////////////////////////////////////////////////////////////////
// BEGIN LEXER
///////////////////////////////////////////////////////////////////////////////////////////////////

SKIP :
{
	" "
	| "\t"
	| "\n"
	| "\r"
}


// COMMENTS
// JavaCC's lexer handles comments (and other ambiguous tokens) differently
// from normal tokens.

MORE :
{
	"#" : IN_SINGLE_LINE_COMMENT
}  

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT : (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT>
MORE :
{
	< ~[] >
}


// Multi-line comments
MORE : { "/*": IN_COMMENT } 
     
// When any other character is seen in the IN_COMMENT state, skip it.
< IN_COMMENT > MORE : { <  ~[] > } 

// When a */ is seen in the IN_COMMENT state, skip it and switch back to the DEFAULT state
< IN_COMMENT > SKIP : { "*/": DEFAULT } 



// Block comments
//SPECIAL_TOKEN : /* COMMENTS */
//{
// <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
//}


TOKEN :
{
	//////////////////////////////////////////////////////////////////////
	// RESERVED KEYWORDS -- core to DML, common to R language
	<IF  		: "if">
	| <ELSE  	: "else">
	| <WHILE  	: "while">
	| <FOR  	: "for">
	| <TRUE  	: "TRUE">
	| <FALSE   : "FALSE">
	| <FUNCTION : "function">

	// RESERVED KEYWORDS -- core to DML, not in R
	| <RETURN 				: "return" >
	| <EXTERNALFUNCTION 	: "externalFunction" >
	| <IMPLEMENTED_IN 		: "implemented in" >
	| <PARFOR 		: "parfor">
	| <PRINT 		: "print">
	| <WRITEMATRIX 	: "write">
	| <WRITEMM		: "writeMM" >
	| <WRITE_CSV	: "write.csv" >

	// RESERVED KEYWORDS -- required for meta-learning
 	| <BUILD_ENSEMBLE	: "build ensemble" >
	| <USE_ENSEMBLE 	: "use ensemble" >
	| <CROSSVAL 		: "crossval">
	| <AGGREGATE   	: "aggregate">
	| <TRAIN	   	: "train" >
	| <TEST			: "test" >
	| <PARTITION	: "partition" >

	// RESERVED KEYWORDS -- required to support import / packages -- NOT common to R
	| <SOURCE		: "source">
	| <SETWD		: "setwd" >
	| <AS  			: "as">
 	
	/////////////////////////////////////////////////////////
	// Operators
	| <PLUS  		: "+">
	| <MINUS  		: "-">
	| <MULT  		: "*">
	| <DIV  		: "/">
	| <MODULUS      : "%%">
	| <INTDIV       : "%/%">
	| <MATRIXMULT 	: "%*%">
	| <POWER  		: "^">
	| <LESSEQUAL  	: "<=">
	| <LESS 		: "<">
	| <GREATEREQUAL : ">=">
	| <GREATER  	: ">">
	| <EQUAL  		: "==">
	| <NOTEQUAL  	: "!=">
	| <ASSIGN  		: "=">
	| <LEFTASSIGN  	: "<-">
	| <CONDITIONALAND  	: "&&">
	| <LOGICALAND  		: "&">
	| <CONDITIONALOR  	: "||">
	| <LOGICALOR  		: "|">
	| <NOT 				: "!">
 
	////////////////////////////////////////////////////////
	// DELIMITERS
 	|  <SEMICOLON  		: ";">
 	|  <COLON  			: ":" >
 	|  <LEFTPAREN   	: "(">
 	|  <RIGHTPAREN  	: ")">
 	|  <COMMA       	: ",">
 	|  <LEFTCURLYPAREN  : "{">
 	|  <RIGHTCURLYPAREN : "}">
 	|  <LEFTSQUARE  	: "[">
 	|  <RIGHTSQUARE  	: "]">
  
 	/////////////////////////////////////////////////////////
 	// LITERALS
 
 	// The name of an optree or an existing annotation type.
 	| <ID : ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_","."])* >
 	| <DOLLAR_ID : "$"["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_","."])* >
 	| <DOLLAR_ID_POS : "$"(["0"-"9"])+ >

 	// A number with no decimal point -- minus sign is a separate token
 	| <INTEGER : (["0"-"9"])+>
 
 	// A number with decimal point -- minus sign is a separate token
 	| <DOUBLE : (["0"-"9"])* "." (["0"-"9"])+  ( ("e"|"E")("-"|"+")? (["0"-"9"])+)? > 
	// A double-quoted string literal (Based on JavaCC.jj)
 	| <DBLQUOTE_STRING_LITERAL :
  	"\""
     	(   (~["\"","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )*
       "\""
    > 

 	// SQL-style string literal in single quotes
 	| <SQL_STRING_LITERAL :
  	"'"
       (   (~["'","\\","\n","\r"])
         | ("\\"
             ( ["n","t","b","r","f","\\","'","\""]
             | ["0"-"7"] ( ["0"-"7"] )?
             | ["0"-"3"] ["0"-"7"] ["0"-"7"]
             )
           )
       )*
       "'"
    > 
} // end TOKEN

///////////////////////////////////////////////////////////////////////////////////////////////////
// END LEXER
///////////////////////////////////////////////////////////////////////////////////////////////////


DMLProgram __inputInternal() :
{
	Statement current = null;
	ArrayList<StatementBlock> groupedStmts = null;
	Token reserved = null;

	DMLParseException runningList = new DMLParseException(this.getFilename());
	boolean skipStatement = false;
}
{  
	try {
		(
			(	
				{					skipStatement = false;
					groupedStmts  = null;
					current = null;
				}
				try {
				  	groupedStmts = GroupedStatements()
					| current = PathStatement() 
					| current = ImportStatement()
					| current = OutputStatement()
					| current = WhileStatement()
					| current = ForStatement()
					| current = IfStatement()
					//| current = MetaLearningStatement()
					| current = AssignValueStatements()
				} catch (DMLParseException e){					runningList.add(e);
					skipStatement = true;
				}	 
			)
			{
				
				if (!skipStatement) {
					if (groupedStmts != null){						for (StatementBlock currSb : groupedStmts)
							this.getDmlp().addStatementBlock(currSb);
							
					} else {					  
						StatementBlock sb = null;
						if (current instanceof WhileStatement) 
							sb = new WhileStatementBlock();
						else if (current instanceof ParForStatement) 
							sb = new ParForStatementBlock();
						else if (current instanceof ForStatement) 
							sb = new ForStatementBlock();
						else if (current instanceof IfStatement)
							sb = new IfStatementBlock(); 
						else if (current instanceof CVStatement){
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML"));
							//sb = new CVStatementBlock();
						}
						else if (current instanceof ELStatement || current instanceof ELUseStatement)
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
						else if (current instanceof FunctionStatement) 
							sb = new FunctionStatementBlock();
						else 
							sb = new StatementBlock();
						sb.addStatement(current);

						if (current instanceof PathStatement){							this.dmlWorkingDir = ((PathStatement)current).getPathValue();
							// add path statement to DML program
	    					this.getDmlp().addStatementBlock(sb);
						}
					
						// handle import statements
						else if (current instanceof ImportStatement) {
		
							// if the path verifies, parse the file to create a DMLProgram
							ImportStatement importStmt = (ImportStatement) sb.getStatement(0);
		
							if (importStmt.verify(dmlWorkingDir)) {
		
								try {
									DMLProgram importedProg = null;
									File moduleFile = new File(importStmt.getCompletePath());
									LOG.info("INFO: line " + importStmt.getBeginLine() + ", column " + importStmt.getBeginColumn() + " -- importing module file: " + ((ImportStatement)current).getCompletePath());
		
									try {										DMLQLParser parser = new DMLQLParser(moduleFile,null);
										parser.setFilename(importStmt.getFilePath());
										importedProg = parser.parse();
									} catch (DMLParseException e){										runningList.add(e);
									}
									       	
									// set the key to be the name of the module or the alias      
									String namespaceKey = (importStmt.getNamespace() == null) ? DMLProgram.DEFAULT_NAMESPACE : importStmt.getNamespace();
			
									if (!this.getDmlp().getNamespaces().containsKey(namespaceKey))
											this.getDmlp().getNamespaces().put(namespaceKey,importedProg);
				  
									else {
										// attempt to import the new functions in the importedProgram (DML file specified in import statement) into the existing namespace
										for (String fname : importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).keySet()){	  
											if (this.getDmlp().getFunctionStatementBlock(namespaceKey,fname) != null)  
												runningList.add(new DMLParseException(this.getFilename(), importStmt.printErrorLocation() + "function " + fname + " already defined in namespace " + namespaceKey));
											else 
				          						this.getDmlp().getFunctionStatementBlocks(namespaceKey).put(fname, importedProg.getFunctionStatementBlock(DMLProgram.DEFAULT_NAMESPACE, fname));   
				       					}
				       				}
								}
								catch(Exception e){
								  	if (e != runningList)
										runningList.add(e);
									throw runningList;
								}
							} 
		    
		    				else {
								runningList.add(new DMLParseException(this.getFilename(), importStmt.printErrorLocation() + "failed to import " + importStmt.toString()));
								throw runningList;
		    				}
		
		    				// add import statement to DML program
		    				this.getDmlp().addStatementBlock(sb);
		
						} // if (current instanceof ImportStatement)
		
						// handle function declarations
						else if (sb instanceof FunctionStatementBlock) {
							FunctionStatement first  = (FunctionStatement)((FunctionStatementBlock)sb)._statements.get(0);
							try {
								// check if the function is defined in the current namespace
								if (this.getDmlp().getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(first.getName())){								    runningList.add(new DMLParseException(this.getFilename(), first.printErrorLocation() + "function " + first.getName() + " already defined in current namespace "));
								}
								this.getDmlp().getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).put(first.getName(), (FunctionStatementBlock)sb);
							} catch (Exception e) {
								runningList.add(e);
							}
						} 
						else {
							this.getDmlp().addStatementBlock(sb);
						}
					}
				}
			}
		[<SEMICOLON>]
	 	)* <EOF>
	
	 	{
	  		this.getDmlp().mergeStatementBlocks();
	  		if (runningList.size() > 0)
	  			throw runningList;
	  		return this.getDmlp();
	 	}

	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


ArrayList<StatementBlock> GroupedStatements() :
{	Statement current = null;
	ForStatement fs = null;
	boolean skipStatement = false;
	ArrayList<StatementBlock> retVal = new ArrayList<StatementBlock>();
	ArrayList<StatementBlock> groupedStmts = new ArrayList<StatementBlock>();

	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		<LEFTCURLYPAREN>
		(
			(
				{
					skipStatement = false;
					groupedStmts  = null;
					current = null;
				}
				try {
		  			groupedStmts = GroupedStatements()
					| current = PathStatement() 
					| current = ImportStatement()
					| current = OutputStatement()
					| current = WhileStatement()
					| current = ForStatement()
					| current = IfStatement()
					//| current = MetaLearningStatement()
					| current = AssignValueStatements()
				} catch (DMLParseException e){
					runningList.add(e);
					skipStatement = true;
				}
			)
			{
				if (!skipStatement) {

					if (groupedStmts != null){
						for (StatementBlock currSb : groupedStmts)
							retVal.add(currSb);		
					} else {					 
						StatementBlock sb = null;
						if (current instanceof WhileStatement) 
							sb = new WhileStatementBlock();
						else if (current instanceof IfStatement) 
							sb = new IfStatementBlock();
						else if (current instanceof ParForStatement) 
							sb = new ParForStatementBlock();
						else if (current instanceof ForStatement) 
							sb = new ForStatementBlock();
						else if (current instanceof FunctionStatement)
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + " Nested function definitions are not supported "));
						else if (current instanceof CVStatement) {
						  	runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML"));
							//sb = new CVStatementBlock();
						}
						else if (current instanceof ELStatement || current instanceof ELUseStatement) 
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
						else 
							sb = new StatementBlock();						
						sb.addStatement(current);

						if (current instanceof PathStatement){
							
							this.dmlWorkingDir = ((PathStatement)current).getPathValue();
							// add path statement to DML program
	    					this.getDmlp().addStatementBlock(sb);
						}
	
						// handle import statements
						else if (current instanceof ImportStatement) {
		
							// if the path verifies, parse the file to create a DMLProgram
							ImportStatement importStmt = (ImportStatement) sb.getStatement(0);
		
							if (importStmt.verify(dmlWorkingDir)) {
		
								try {
									DMLProgram importedProg = null;
									File moduleFile = new File(importStmt.getCompletePath());
									LOG.info("INFO: line " + importStmt.getBeginLine() + ", column " + importStmt.getBeginColumn() + " -- importing module file: " + ((ImportStatement)current).getCompletePath());
		
									try {
										DMLQLParser parser = new DMLQLParser(moduleFile,null);
										parser.setFilename(importStmt.getFilePath());
										importedProg = parser.parse();
										
									} catch (DMLParseException e){
										runningList.add(e);
									}
									       	
									// set the key to be the name of the module or the alias      
									String namespaceKey = (importStmt.getNamespace() == null) ? DMLProgram.DEFAULT_NAMESPACE : importStmt.getNamespace();
			
									if (!this.getDmlp().getNamespaces().containsKey(namespaceKey)) {
										this.getDmlp().getNamespaces().put(namespaceKey,importedProg);
				  
									} else {
										// attempt to import the new functions in the importedProgram (DML file specified in import statement) into the existing namespace
										for (String fname : importedProg.getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).keySet()){	  
											if (this.getDmlp().getFunctionStatementBlock(namespaceKey,fname) != null)  
												runningList.add(new DMLParseException(this.getFilename(), importStmt.printErrorLocation() + "function " + fname + " already defined in namespace " + namespaceKey));
											else 
				          						this.getDmlp().getFunctionStatementBlocks(namespaceKey).put(fname, importedProg.getFunctionStatementBlock(DMLProgram.DEFAULT_NAMESPACE, fname));   
				       					}
				       				}
								}
								catch(Exception e){
								  	if (e != runningList)
										runningList.add(e);
									throw runningList;
								}
							} 
		    
		    				else {
								runningList.add(new DMLParseException(this.getFilename(), importStmt.printErrorLocation() + "failed to import " + importStmt.toString()));
								throw runningList;
		    				}
		
		    				// add import statement to DML program
		    				retVal.add(sb);
		
						} // if (current instanceof ImportStatement)
		
						// handle function declarations
						else if (sb instanceof FunctionStatementBlock) {
							FunctionStatement first  = (FunctionStatement)((FunctionStatementBlock)sb)._statements.get(0);
							try {
								// check if the function is defined in the current namespace
								if (this.getDmlp().getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).containsKey(first.getName())){
								    runningList.add(new DMLParseException(this.getFilename(), first.printErrorLocation() + "function " + first.getName() + " already defined in current namespace "));
								}
								this.getDmlp().getFunctionStatementBlocks(DMLProgram.DEFAULT_NAMESPACE).put(first.getName(), (FunctionStatementBlock)sb);
							} catch (Exception e) {
								runningList.add(e);
							}
						} 
						else {
							retVal.add(sb);
						}
					}
				}
			}
		[<SEMICOLON>]
		)*
	   	<RIGHTCURLYPAREN>
	  
	 	{
			if (runningList.size() > 0){
				throw runningList;
			} else {
				return retVal;
	 		}
	 	}

 	} catch (Exception e){
	  	if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


ForStatement ForStatement() :
{
	Statement current = null;
	ArrayList<StatementBlock> groupedStmts = null;
	IterablePredicate ip = null;
	Token tStart = null;
	ForStatement fs = null;
	boolean skipStatement = false;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try {	  
		(tStart = <FOR> | tStart = < PARFOR >)
		{	   
			if (tStart.image.equals("for"))
				fs = new ForStatement();
			else
				fs = new ParForStatement();
		}
		try {
			ip = IterablePredicate()
			{ fs.setPredicate(ip); }
		} catch (DMLParseException e){			runningList.add(e);
		}		
		
		(
			{
				skipStatement = false;
				groupedStmts = null;
				current = null;
			}
			try {
				groupedStmts = GroupedStatements()
	  			| current = OutputStatement()
				| current = WhileStatement()
				| current = ForStatement()
				| current = IfStatement()
			//	| current = MetaLearningStatement()
				| current = AssignValueStatements()
			} catch (DMLParseException e){				runningList.add(e);
				skipStatement = true;
			}
		)
		{
		  
			if (!skipStatement) {
				if (groupedStmts != null){					fs.setBody(groupedStmts);
				} else {
					StatementBlock sb = null;
					if (current instanceof WhileStatement) 
						sb = new WhileStatementBlock();
					else if (current instanceof IfStatement) 
						sb = new IfStatementBlock();
					else if (current instanceof ParForStatement) 
						sb = new ParForStatementBlock();
					else if (current instanceof ForStatement) 
						sb = new ForStatementBlock();
					else if (current instanceof FunctionStatement)
						runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + " Nested function definitions are not supported "));
					else if (current instanceof CVStatement) {
					  	runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML"));
						//sb = new CVStatementBlock();
					}
					else if (current instanceof ELStatement || current instanceof ELUseStatement) 
						runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
					else 
						sb = new StatementBlock();
					
					sb.addStatement(current);
					fs.addStatementBlock(sb);
				}
			}
		}

	 	{
			if (runningList.size() > 0){
				throw runningList;
			} else {				fs.mergeStatementBlocks();
				if (tStart != null && fs.getBody() != null && fs.getBody().size() > 0){					StatementBlock lastSb = fs.getBody().get(fs.getBody().size()-1); 
					fs.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, lastSb.getEndLine(), lastSb.getEndColumn());
				}
				return fs;
	 		}
	 	}

 	} catch (Exception e){
	  	if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


Statement AssignValueStatements() :
{	DataIdentifier id = null;
	ConstIdentifier constId = null;
	ArrayList<ArrayList<Expression>> targetListList = null;
	Expression source = null;
	Token t = null, commaToken = null, tEnd = null;
	
	Vector <DataIdentifier> functionInputs  = new Vector<DataIdentifier>();
	Vector<DataIdentifier > functionOutputs = new Vector<DataIdentifier>() ;
	FunctionStatement fstmt = new FunctionStatement();
	ExternalFunctionStatement efstmt = null;
	Statement current = null;

	HashMap<String,String> map = null;

	ArrayList<StatementBlock> groupedStmts = null;
	boolean skipStatement = false;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
	  
		(
			try {			  id = Identifier()
			  |			  targetListList = ReadIndexList()
			} catch (DMLParseException e) {
				runningList.add(e);
			}		)	  
		
		( t = <ASSIGN> | t = <LEFTASSIGN>)
		(	  
			(	    
				<FUNCTION>
					try {						functionInputs = ReadTypedArgList()
					} catch (DMLParseException e) {						runningList.add(e);
					}
	
				(
			  		<RETURN>
	
					try {
						functionOutputs = ReadTypedArgList()
					} catch (DMLParseException e) {						runningList.add(e);
					} 
				)?

				try {				  groupedStmts = GroupedStatements()
				} catch (DMLParseException e){					runningList.add(e);
				}	

				{
					if (runningList.size() > 0){
						throw runningList;
					} else {
						fstmt.setBody(groupedStmts);
					  	fstmt.mergeStatementBlocks(); 
						fstmt._inputParams = functionInputs ;
						if (functionOutputs != null)
							fstmt._outputParams = functionOutputs ;
						
						// set the function name
						if (id == null || (id != null && id instanceof IndexedIdentifier)){
							runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t.beginLine, t.beginColumn) + "function can only be assigned to single non-indexed identifier"));
						} else {							fstmt.setName(id.getName());
						}
				
						// track position for start / end token tStart
						if (fstmt.getBody() != null && fstmt.getBody().size() > 0){
						  	StatementBlock firstSb = fstmt.getBody().get(0);
						  	StatementBlock lastSb  = fstmt.getBody().get(fstmt.getBody().size()-1);
							fstmt.setAllPositions(this.getFilename(), firstSb.getBeginLine(), firstSb.getBeginColumn(), lastSb.getEndLine(), lastSb.getEndColumn());
						}
						if (runningList.size() > 0)								
							throw runningList;
						return fstmt;
					}
				}
			)
		 
			|
				
			( 				<EXTERNALFUNCTION>
	
					try {						functionInputs = ReadTypedArgList()
					} catch (DMLParseException e) {						runningList.add(e);
					}
				(
				  	<RETURN>
					try {						functionOutputs = ReadTypedArgList()
					} catch (DMLParseException e) {
						runningList.add(e);
					}
				)?
				
				tEnd = <IMPLEMENTED_IN>
					try {						map = ReadGenericParamList()
					} catch (DMLParseException e) {
						runningList.add(e);
					}
		 
				{
					if (runningList.size() > 0){
						throw runningList;
					} else {			  
						efstmt = new ExternalFunctionStatement(functionInputs, functionOutputs, map);
		
						// set the function name
						if (id == null || (id != null && id instanceof IndexedIdentifier))
							throw new DMLParseException(this.getFilename(), printErrorLocation(t.beginLine, t.beginColumn) + "function can only be assigned to single non-indexed identifier");
						else
							efstmt.setName(id.getName());
							
						if (t != null && tEnd != null)
							efstmt.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn, tEnd.beginLine, tEnd.beginColumn);	
				     	return efstmt;
			    	}
			  	}
			)
	
			| 
	
			( 
				try {				  source = Expression()
				} catch (DMLParseException e) {
					runningList.add(e);
				}
	
				{
					if (runningList.size() > 0){					  throw runningList;
					} else {
						if (id != null) {

							if (id.getName() != null && id.getName().startsWith("$")){

								// check if the parameter variable has passed in value.
								// If value passed in, then change source to use passed in value.

								String argVal = commandArgs.get(id.getName());
	
								if (argVal != null) {								  	
									try { 
									 	// try to assign to long value
										Long longVal = new Long(argVal);
										constId = new IntIdentifier(longVal);
										constId.setAllPositions(this.getFilename(), id.getBeginLine(), id.getBeginColumn(), id.getBeginLine(), id.getBeginColumn());
										
									} catch(Exception e1){
									  	try {
									  	  	// try to assign to double value
									  	  	Double doubleVal = new Double(argVal);
									  	  	constId = new DoubleIdentifier(doubleVal);
									  	  	constId.setAllPositions(this.getFilename(), id.getBeginLine(), id.getBeginColumn(), id.getBeginLine(), id.getBeginColumn());
									  	  
									  	} catch (Exception e2) {
						
											// try to assign to boolean value
											if (argVal.equalsIgnoreCase("true") || argVal.equalsIgnoreCase("false")){   
												Boolean boolVal = new Boolean(argVal);
									  	  		constId = new BooleanIdentifier(boolVal);
									  	  		constId.setAllPositions(this.getFilename(),id.getBeginLine(), id.getBeginColumn(), id.getBeginLine(), id.getBeginColumn());
											}
											else {
											  	// try to assign to string value
												constId = new StringIdentifier(argVal);
												constId.setAllPositions(this.getFilename(), id.getBeginLine(), id.getBeginColumn(), id.getBeginLine(), id.getBeginColumn());
											}	
						
									  	} // end catch e2
										  						  	 
									} // end catch e1
									source = constId;
							   	} else {									// add the dollar param value to the passed arg list
									// check that dollar param is a constant
									if (!(source instanceof ConstIdentifier)){
										runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(id.getBeginLine() , id.getBeginColumn()) + "Can only assign dollar-param variable a constant value"));
										throw runningList;
									} else if (source == null) {										runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(id.getBeginLine() , id.getBeginColumn()) + "For dollar param " + id.getName() + " value is undefined"));										throw runningList;
									} else {										commandArgs.put(id.getName(), source.toString()); 
									}
						  		}
							}
								    
							AssignmentStatement astmt = new AssignmentStatement(id, source);
							if (t != null && source != null)
								astmt.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn, source.getEndLine(), source.getEndColumn());
							return astmt;
						} else { 	
							MultiAssignmentStatement mastmt =  new MultiAssignmentStatement(targetListList, source, 0);
							if (t != null && source != null)
								mastmt.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn, source.getEndLine(), source.getEndColumn());
							return mastmt;
						}
					}
				}
			)
		)
		
		
	} catch (Exception e){		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}	


PathStatement PathStatement():
{
	// track start / end token positions
	Token tStart = null, t1 = null;
	PathStatement pstmt = null;
}
{
	try {	  
		tStart = <SETWD> <LEFTPAREN> t1 = <DBLQUOTE_STRING_LITERAL> <RIGHTPAREN>		{
			String dequotedString = dequoteStr('\"',t1.image);
			pstmt = new PathStatement(dequotedString);
			pstmt.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, t1.endLine, t1.endColumn);
			return pstmt;
		}
	} catch (Exception e){		throw new DMLParseException(getFilename(), e);
	}
}


ImportStatement ImportStatement() :
{
	// track start / end token positions
	Token tStart = null, t1 = null, t4 = null;
	ImportStatement importStmt = new ImportStatement();
}
{
	try {	  
		tStart = <SOURCE><LEFTPAREN> t1 = <DBLQUOTE_STRING_LITERAL> <RIGHTPAREN>
		{
			String dequotedString = dequoteStr('\"',t1.image);
			importStmt.setFilePath(dequotedString);
		}

			[
				"as" t4 = <ID>
				{
					importStmt.setNamespace(t4.image);
				}
			] 

		{ 
			// track position for start / end token tStart
			int elp = (t4 != null) ? t4.endLine   : t1.endLine;
			int ecp = (t4 != null) ? t4.endColumn : t1.endColumn;
			importStmt.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, elp, ecp);
			return importStmt;
		}
	} catch (Exception e){		throw new DMLParseException(getFilename(), e);
	}
}


HashMap <String,String > ReadGenericParamList() :
{
	HashMap<String,String > map = new HashMap<String,String >() ;
	Token t1 = null, t2 = null, t4 = null;
	IntIdentifier intid = null;
	DoubleIdentifier doubleid = null;
	BooleanIdentifier boolid = null;

	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		<LEFTPAREN>
		(
			{t4 = null;}
			(t4 = <COMMA>)? t1 = <ID> <ASSIGN>
	
			(
				LOOKAHEAD(2) intid = IntConstant() { map.put(t1.image, intid.toString()); }
				| doubleid = DoubleConstant() { map.put(t1.image, doubleid.toString());   }
				| boolid = BooleanConstant()  { map.put(t1.image, boolid.toString());     }
				| t2 = <SQL_STRING_LITERAL>   { map.put(t1.image, dequoteStr('\'',t2.image));    }
				| t2 = <DBLQUOTE_STRING_LITERAL> { map.put(t1.image, dequoteStr('\"',t2.image)); }
			)
			
			{
				if (map.size() == 1 && t4 != null)
					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t4.beginLine, t4.beginColumn) + "extra comma before first parameter"));
				if (map.size() > 1 && t4 == null)
					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t4.beginLine, t4.beginColumn) + "missing comma before parameter " + map.size() + 1));
				t4 = null;
			}
			
		)*
		<RIGHTPAREN>
		{
			if (runningList.size() > 0)
				throw runningList;
	  		return map ;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


// NOTE: DML only supports default values for scalar datatype
Vector<DataIdentifier> ReadTypedArgList() :
{
	Vector<DataIdentifier> params = new Vector<DataIdentifier>() ;
	DataIdentifier d1=null, d2=null ;
	Token t1 = null, t2 = null, t3 = null, commaToken = null;
	String valueType = null;
	String dataType = null;
	IntIdentifier intid = null;
	DoubleIdentifier doubleid = null;
	BooleanIdentifier boolid = null;

	DMLParseException runningList = new DMLParseException(this.getFilename());
} 
{

	try {	  
		<LEFTPAREN>
		(
			{ commaToken = null; }
			( commaToken = <COMMA>)?  t1 = <ID> [<LEFTSQUARE> t2 = <ID> <RIGHTSQUARE>]  d2 = Identifier() 
	
	  		(
				<ASSIGN> intid = IntConstant()     { d2.setDefaultValue(intid.toString());}
		    		| doubleid = DoubleConstant() { d2.setDefaultValue(doubleid.toString()); }
		    		| boolid = BooleanConstant()  { d2.setDefaultValue(boolid.toString()); }
		    		| t3 = <SQL_STRING_LITERAL>   { d2.setDefaultValue(dequoteStr('\'',t3.image)); }
		    		| t3 = <DBLQUOTE_STRING_LITERAL> {d2.setDefaultValue(dequoteStr('\"',t3.image));}
		  	)?
	
			{
				if (commaToken != null && params.size() == 0)
					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(commaToken.beginLine, commaToken.beginColumn) + "extra comma before first parameter"));
	
				if (commaToken == null && params.size() > 0)
					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t1.beginLine, t1.beginColumn) + "missing comma before function call parameter " + params.size()));
	
				if (t1.image.equalsIgnoreCase("matrix")){
					if (t2 == null){
						runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t1.beginLine, t1.beginColumn)
								+ " cannot process argument " + (params.size() + 1) + " for UDF " + t1.image
								+ ". Valuetype (int, double, boolean, String) must be defined for Matrix datatype "
								+ " -- e.g., Matrix(Double) "));
		    		}
		    		else {
		     			dataType = "matrix";
		    	 		valueType = t2.image;
		    		}
		     	}
				else if (t1.image.equalsIgnoreCase("object")){
		    		dataType = "object";
		    		valueType = "object";
		   		}
		     	else {
		        	dataType = "scalar";
		         	valueType = t1.image;
		   		}  
		     	d2.setTypeInfo(valueType, dataType);        
		       	params.add(d2);
		  	}
	 	)*
		<RIGHTPAREN>
		
	} catch (DMLParseException e){		runningList.add(e);
		throw runningList;
	}
	{
		if (runningList.size() > 0)
			throw runningList;
		return params;
	}
}


ArrayList<ArrayList<Expression>> ReadIndexList() :
{
	ArrayList<ArrayList<Expression>> targetListList = new ArrayList<ArrayList<Expression>>();
	ArrayList<Expression> targetList = null;
	Expression target = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{ 
	try {	  
		<LEFTSQUARE>
		(
			try {			  
				LOOKAHEAD(ColonDelimitedExpression())
				targetList = ColonDelimitedExpression() {targetListList.add(targetList);}
	     		|
	     		target = Expression() {targetList = new ArrayList<Expression>(); targetList.add(target); targetListList.add(targetList); } 	
			} catch (DMLParseException e) {
				runningList.add(e);
			}
		)?
		{
		  	// CASE: no indexing dimensions given
			if (targetList == null){
				targetList = new ArrayList<Expression>();
				targetList.add(null);
				targetList.add(null);
				targetListList.add(targetList);
			}
			targetList = null;
		}
    
		(
			<COMMA>
			(
				try {	
					LOOKAHEAD( ColonDelimitedExpression())
					targetList = ColonDelimitedExpression() {targetListList.add(targetList);}
					|
					target = Expression() { targetList = new ArrayList<Expression>(); targetList.add(target); targetListList.add(targetList);}
				} catch (DMLParseException e) {
					runningList.add(e);
				}				  
	   		)?
	   		{	   	  	
				// CASE: no indexing dimesnions given
				if (targetList == null)
				{
					targetList = new ArrayList<Expression>();
					targetList.add(null);
					targetList.add(null);
					targetListList.add(targetList);
				}
				targetList = null;
	   		}
	  	)* 
	  	<RIGHTSQUARE>
	  	
	} catch (Exception e){		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
	{
		if (runningList.size() > 0)
			throw runningList;
		return targetListList;
	}
}


ArrayList<Expression> ColonDelimitedExpression() :
{
	ArrayList<Expression> exprsList = new ArrayList<Expression>();
	Expression left = null, right = null;
	Token tStart = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {	  
	 	[
			try {
	 			left = Expression()
	 		} catch (DMLParseException e){
				runningList.add(e);
	 		}
	 	]
	 	
	 	tStart = <COLON>
	
	 	[
	 		try {
	 			right = Expression()
	 		} catch (DMLParseException e){
				runningList.add(e);
	 		}
	 	]
	 	
	} catch(Exception e){
		if (e != runningList)			runningList.add(e);
		throw runningList;
	}
 	{
		if (left == null && right == null)
			runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tStart.beginLine, tStart.beginColumn) + " colon delimiter cannot be specified when no indexing expressions used"));

  		exprsList.add(left);
  		exprsList.add(right); 
		if (runningList.size() > 0)
			throw runningList;
  		return exprsList;
	}
}


IfStatement IfStatement() :
{
	IfStatement is = new IfStatement();
	Statement current = null;
	ConditionalPredicate cp = null;
	Token tStart = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
	boolean skipStatement = false;
	ArrayList<StatementBlock> groupedStmts = null;
}
{
	try {	  
		tStart = <IF>
	
		try {			cp = ConditionalPredicate()
			{ is.setConditionalPredicate(cp); }
		}
		catch (DMLParseException e){
			runningList.add(e);
		}		  
	 	(
			(
				{
					skipStatement = false;
					groupedStmts = null;
					current = null;
				}		 
				try {
				  	groupedStmts = GroupedStatements()
					| current = OutputStatement()
					| current = WhileStatement()
					| current = ForStatement()
					| current = IfStatement()
					//| current = MetaLearningStatement()
					| current = AssignValueStatements()
				} catch (DMLParseException e){					runningList.add(e);
					skipStatement = true;
				}
		   	)
			{				if (!skipStatement) {

					if (groupedStmts != null && is != null){
						is.setIfBody(groupedStmts);
					} else {			
						StatementBlock sb = null;
						if (current instanceof WhileStatement) 
				 			sb = new WhileStatementBlock();
						else if (current instanceof IfStatement) 
							sb = new IfStatementBlock();
						else if (current instanceof ParForStatement) 
							sb = new ParForStatementBlock();
						else if (current instanceof ForStatement) 
							sb = new ForStatementBlock();
						else if (current instanceof FunctionStatement)
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + " Nested function definitions are not supported "));
						else if (current instanceof CVStatement) {
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML"));
							//sb = new CVStatementBlock();
						}
						else if (current instanceof ELStatement || current instanceof ELUseStatement) 
						  	runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
						else 
							sb = new StatementBlock();
						
						sb.addStatement(current);
						is.addStatementBlockIfBody(sb);
					}
				}
			}
		)
	 	{
			if (is != null)
				is.mergeStatementBlocksIfBody();
	 	}
	
	 	(
			LOOKAHEAD(1) <ELSE>
			(
		   		(
					(
						{
							skipStatement = false;
							groupedStmts = null;
							current = null;
						}
						try {
							groupedStmts = GroupedStatements()
							|  current = OutputStatement()
							| current = WhileStatement()
							| current = ForStatement()
							| current = IfStatement()
						//	| current = MetaLearningStatement()
							| current = AssignValueStatements()
						} catch (DMLParseException e){							runningList.add(e);
							skipStatement = true;
						}
		   			)
		   			{  
		   				if (!skipStatement) {

							if (groupedStmts != null){
								is.setElseBody(groupedStmts);

							} else {	  			   				  
							    StatementBlock sb = null;
							    if (current instanceof WhileStatement) 
							    	sb = new WhileStatementBlock();
							    else if (current instanceof IfStatement) 
							    	sb = new IfStatementBlock();
							    else if (current instanceof ParForStatement) 
							    	sb = new ParForStatementBlock(); 
							    else if (current instanceof ForStatement) 
							    	sb = new ForStatementBlock();
								else if (current instanceof FunctionStatement)
									runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + " Nested function definitions are not supported "));
							  	else if (current instanceof CVStatement) {
									runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML"));
									//sb = new CVStatementBlock();
								}
								else if (current instanceof ELStatement || current instanceof ELUseStatement)
								  	runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
							    else 
							    	sb = new StatementBlock();
							    
							    sb.addStatement(current);
							    is.addStatementBlockElseBody(sb);
							}
						}
					}
		   		)
		  		{
					if (is != null)
		    			is.mergeStatementBlocksElseBody();
		  		}
	  		) 
		)? 
	 	{
			if (runningList.size() > 0) {
				throw runningList;
			} else {
			  	StatementBlock lastSb = null;
			  	if (is.getElseBody() != null && is.getElseBody().size() > 0)
			  		lastSb = is.getElseBody().get(is.getElseBody().size()-1);
				else if (is.getIfBody() != null && is.getIfBody().size() > 0)
					lastSb = is.getIfBody().get(is.getIfBody().size()-1);

				if (tStart != null && lastSb != null)
					is.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, lastSb.getEndLine(), lastSb.getEndColumn());
				return is;
	 		}
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


WhileStatement WhileStatement() :
{
	WhileStatement ws = new WhileStatement();
	Statement current = null;
	ConditionalPredicate cp = null;
	Token tStart = null, tEnd = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
	boolean skipStatement = false;
	ArrayList<StatementBlock> groupedStmts = null;
}
{	try {
		tStart = <WHILE>
	
		try {
			cp = ConditionalPredicate()
			{ ws.setPredicate(cp); }
		} catch (DMLParseException e){			runningList.add(e);
		}

	  	(
			(
				{
					skipStatement = false;
					groupedStmts = null;
					current = null;
				}		 
				try {
					groupedStmts = GroupedStatements()				  
					| current = OutputStatement()
					| current = WhileStatement()
					| current = ForStatement()
					| current = IfStatement()
					//| current = MetaLearningStatement()
					| current = AssignValueStatements()
				} catch (DMLParseException e) {					runningList.add(e);
					skipStatement = true; 
				} 
			)
			{			  	if (!skipStatement) {

					if (groupedStmts != null){
						ws.setBody(groupedStmts);
				
					} else {  
						StatementBlock sb = null;
						if (current instanceof WhileStatement)
					   		sb = new WhileStatementBlock();
					  	else if (current instanceof IfStatement) 
					   		sb = new IfStatementBlock();
					  	else if (current instanceof ParForStatement) 
					   		sb = new ParForStatementBlock();
					  	else if (current instanceof ForStatement) 
					   		sb = new ForStatementBlock();
					 	else if (current instanceof FunctionStatement)
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + " Nested function definitions are not supported "));
						else if (current instanceof CVStatement) {
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"crossval\" not supported in DML")); 
							//sb = new CVStatementBlock();
						}
						else if (current instanceof ELStatement || current instanceof ELUseStatement)
							runningList.add(new DMLParseException(this.getFilename(), current.printErrorLocation() + "\"ensemble\" not supported in DML"));
					  	else 
				   			sb = new StatementBlock();
				  		
				  		sb.addStatement(current);
				  		ws.addStatementBlock(sb);
					}
				}
			}
		)

	 	{
			if (runningList.size() > 0){
				throw runningList;
			} else {
				ws.mergeStatementBlocks();
				if (tStart != null && ws.getBody() != null && ws.getBody().size() > 0){
					StatementBlock lastSb = ws.getBody().get(ws.getBody().size()-1); 
					ws.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, lastSb.getEndLine(), lastSb.getEndColumn());
				}
				return ws;
	 		}
		}
	} catch (DMLParseException e) {		if (e != runningList)
			runningList.add(e);
			throw runningList;
	}
}


IterablePredicate IterablePredicate() :
{
	 DataIdentifier iterVar = null;
	 Expression fromExpr = null, toExpr = null, incrementExpr = null;
	 FunctionCallIdentifier fci = null;
	 Token paramName = null, paramVal = null;
	 HashMap<String,String> parforParamValues = new HashMap<String,String>();
	 ArrayList<Expression> exprParams = new ArrayList<Expression>();
	 Token tStart = null, tEnd = null, tSeq = null, tIn = null;
	
	 DMLParseException runningList = new DMLParseException(this.getFilename());
}
{  
	try {
	  
		tStart = <LEFTPAREN>
	
		try {
		 	iterVar = Identifier()
		} catch (DMLParseException e){
			runningList.add(e);
		}		  
		tIn = <ID>
	
		(
			try {			  
				LOOKAHEAD(ColonDelimitedExpression()) exprParams = ColonDelimitedExpression()
				|
				(tSeq = <ID> fci = FunctionCall())

			} catch (DMLParseException e){				runningList.add(e);
			}
			
		)
	
		(
			<COMMA> paramName = <ID> <ASSIGN> (paramVal = <INTEGER> | paramVal = <ID>)
			{
				if (paramName != null && paramVal != null)
					parforParamValues.put(paramName.image, paramVal.image);
			}
		)*
	
		{
			if (tIn != null && !tIn.image.equals("in"))
			    runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tIn.beginLine, tIn.beginColumn) +"for iterable predicate, token after variable must be \"in\"")); 
	          
			if (tSeq != null && !tSeq.image.equals("seq"))
			  	runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tIn.beginLine, tIn.beginColumn) +"for iterable predicate, only function supported is seq")); 
				 
	   		if (fci == null && exprParams == null)				runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tStart.beginLine, tStart.beginColumn) + "iterable predicate in for loop must specify parameters")); 
	   		    
			if (fci != null) {
	    		ArrayList<ParameterExpression> seqExprs = fci.getParamExprs();
	
	    		if (seqExprs.size() <  2)					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq must specify both from and to value"));
	    	    	
	    		else if (seqExprs.size() > 3) 					runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tSeq.beginLine, tSeq.beginColumn) + "seq cannot specify more than 3 args -- from, to, increment"));
	
	    		else {
	     			fromExpr = seqExprs.get(0).getExpr();
	     			toExpr   = seqExprs.get(1).getExpr();
	     			IntIdentifier oneExpr = new IntIdentifier(1);
	     			incrementExpr = (seqExprs.size() == 3) ? seqExprs.get(2).getExpr() : oneExpr;  
	    		} 
	   		}
	   		else {
	    		// use exprParams
	    		if (exprParams.size() >= 2){
					fromExpr = exprParams.get(0);
	    			toExpr   = exprParams.get(1);
	    			incrementExpr = new IntIdentifier(1);
	   			}
	   		}
	    	
	  	}
		  
		tEnd = <RIGHTPAREN>
		{
			if (runningList.size() > 0) {
				throw runningList;
			} else {				IterablePredicate retVal = new IterablePredicate(iterVar, fromExpr, toExpr, incrementExpr, parforParamValues);
				retVal.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, tEnd.beginLine, tEnd.beginColumn);	
				return retVal;
			}
		}
	} catch (Exception e) {		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}	  
}


ConditionalPredicate ConditionalPredicate() :  
{
	Expression expr = null;
	Token tStart = null, tEnd = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		tStart = <LEFTPAREN>
		try {			expr = Expression()
		} catch (DMLParseException e) {			runningList.add(e);
		}
		tEnd = <RIGHTPAREN>
		{
			if (runningList.size() > 0) {  
				throw runningList;
			} else {
				ConditionalPredicate retVal = new ConditionalPredicate(expr);
				retVal.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, tEnd.beginLine, tEnd.beginColumn);
				return retVal;
			}
		}
	} catch (Exception e){
	  	if (e != runningList)
	  		runningList.add(e);		throw runningList; 
	}
}


Expression Expression() : 
{
	Expression expr = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		(			try {				expr = BooleanOrExpression()
			} catch (DMLParseException e){				runningList.add(e);
			}
		)

		{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
	  	if (e != runningList)
	  		runningList.add(e);
		throw runningList; 
	}
}


Expression BooleanOrExpression() :  
{
	Expression expr = null, left = null, right = null;
	Token t = null;
	Expression.BooleanOp bop = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try {
	  	try {			expr = BooleanAndExpression()
		} catch (DMLParseException e){			runningList.add(e);
		} 
		(
			(
				t = <CONDITIONALOR> | t = <LOGICALOR>
			) 
			{
				bop = Expression.getBooleanOp(t.image);
			}
			try {
		     	right = BooleanAndExpression() 
		     	{
		        	left = expr;
					BooleanExpression exprb = new BooleanExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn );
					exprb.setLeft(left);
					exprb.setRight(right);
					expr = exprb;
				}
			} catch (DMLParseException e) {
				runningList.add(e);
			}
		)*
	 	{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e) {
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}	
}

 
Expression BooleanAndExpression() : 
{
	Expression expr = null, left = null, right = null;
	Expression.BooleanOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		expr = BooleanNotExpression() 
	 	(
			try {
		     	(t = <CONDITIONALAND> | t = <LOGICALAND>) {bop = Expression.getBooleanOp(t.image); }
		     	right = BooleanNotExpression() 
		      	{
					left = expr;
		       		BooleanExpression exprb = new BooleanExpression(bop, this.getFilename(), t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
		       		exprb.setLeft(left);
		       		exprb.setRight(right);
		       		expr = exprb;
		      	}
		     } catch (DMLParseException e){				runningList.add(e);
		     }
	    )*
		{	
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression BooleanNotExpression() : 
{
	Expression expr = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	  
	try {
	  
		[ t = <NOT> ]

		try {			expr = RelationalExpression() 
		} catch (DMLParseException e){			runningList.add(e);	
		}
	     
	    {
	      	if (t == null) {	 			if (runningList.size() > 0)
					throw runningList;
	     		return expr;
			} else {
	   			Expression.BooleanOp bop = Expression.getBooleanOp(t.image); 
	   			Expression left = expr;
	   			BooleanExpression notexpr = new BooleanExpression(bop, this.getFilename(), t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
	   			notexpr.setLeft(left);
				if (runningList.size() > 0)
					throw runningList;
	   			return notexpr;
	   		}
	  	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression RelationalExpression() :
{
	Expression expr = null,left = null, right = null; 
	Expression.RelationalOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try {
	  	try {			expr = PlusMinusExpression()
		} catch (DMLParseException e) {			runningList.add(e);
		} 
		(
	   		(t=<LESSEQUAL> | t=<LESS> | t=<GREATEREQUAL> | t=<GREATER> | t=<EQUAL> | t=<NOTEQUAL>) 
	   		{bop = Expression.getRelationalOp(t.image); }

			try {  
		     	right =  PlusMinusExpression()
		    } catch (DMLParseException e) {
				runningList.add(e);
			}
	       	{
	        	left = expr;
				if (t != null){					RelationalExpression exprb = new RelationalExpression(bop, this.getFilename(), t.beginLine, t.beginColumn,t.beginLine, t.beginColumn);
	       			exprb.setLeft(left);
	      	 		exprb.setRight(right);
	       			expr = exprb;
	      		}
	      	}	  
		)*
	 	{
			if (runningList.size() > 0)
				throw runningList;
	   		return expr;
	   	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression PlusMinusExpression() : 
{
	Expression expr = null, left = null, right = null;
	Expression.BinaryOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
	  	try {			expr = MultDivExpression()
		} catch (DMLParseException e) {
			runningList.add(e);
		}  
	 	(LOOKAHEAD(2)
	   		
	    	(t = <PLUS> | t = <MINUS>)  {bop = Expression.getBinaryOp(t.image); }
			try {			  	right = MultDivExpression()
			} catch (DMLParseException e) {				runningList.add(e);
			} 
	    	{
	     		left = expr;
	    		BinaryExpression exprb = new BinaryExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
	    		exprb.setLeft(left);
	    		exprb.setRight(right);
	    		expr = exprb;
	   		}
		)*
	 	{ 
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression MultDivExpression() : 
{
	Expression expr = null, left = null, right = null;
	Expression.BinaryOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		try {		  	expr = MatrixMultExpression()
		} catch (DMLParseException e) {			runningList.add(e);
		} 
	 	(
	   		
	   		(t = <MULT> | t = <DIV> | t = <MODULUS> | t = <INTDIV>)  {bop = Expression.getBinaryOp(t.image); }
			try {			  	right = MatrixMultExpression()
			} catch (DMLParseException e){				runningList.add(e);
			} 
	   		{
			    left = expr;
			    BinaryExpression exprb = new BinaryExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
			    exprb.setLeft(left);
			    exprb.setRight(right);
			    expr = exprb;
	   		}
	    )*
	 	{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}	


Expression MatrixMultExpression() : 
{
	Expression expr = null, left = null, right = null;
	Expression.BinaryOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}

{	try {
	  	try {	  	  	expr = UnaryExpression()
	  	} catch (DMLParseException e){			runningList.add(e);
	  	} 
	 	(
	  		t = <MATRIXMULT>  {bop = Expression.getBinaryOp(t.image); }

			try {			  	right =  UnaryExpression()
			} catch (DMLParseException e){				runningList.add(e);
			} 
	 		{
				left = expr;
				if (t != null) {  
					BinaryExpression exprb = new BinaryExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
					exprb.setLeft(left);
					exprb.setRight(right);
					expr = exprb;
				}
	   		}
	    )*
		{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression UnaryExpression() : 
{
	Expression expr = null, right = null;
	BinaryOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		(
			try {			  
			  	LOOKAHEAD(3) expr = PowerExpression()
			  	|
			  	(  			
		   			(t = <PLUS> | t =  <MINUS>)  {bop = Expression.getBinaryOp(t.image); }
					try {					  	right = PowerExpression() 
					} catch (DMLParseException e){						runningList.add(e);
					}  
		     		{
						if (t != null){							BinaryExpression exprb = new BinaryExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
		     				IntIdentifier id = new IntIdentifier(0);
							exprb.setLeft(id);
							exprb.setRight(right);
							expr = exprb;
						}
		     		}
		     	)
		    } catch (DMLParseException e){				runningList.add(e);
		    }
		)
		{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList; 
	}
}


Expression PowerExpression() : 
{
	Expression expr = null, left = null, right = null;
	Expression.BinaryOp bop = null;
	Token t = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		try {			expr = PrimaryExpression()
		} catch (DMLParseException e) {			runningList.add(e);
		}

	  	[ 				t = <POWER>  {bop = Expression.getBinaryOp(t.image); }
			try {			  	right = PowerExpression() 
			} catch (DMLParseException e) {
				runningList.add(e);
			}			  
    		{
     			left = expr;
				if (t != null){					BinaryExpression exprb = new BinaryExpression(bop, this.getFilename(), t.beginLine, t.beginColumn, t.beginLine, t.beginColumn);
    				exprb.setLeft(left);
    				exprb.setRight(right);
					expr = exprb;
    			}
    			
   			}
	    ]
		{
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		}
	} catch (Exception e) {
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


Expression PrimaryExpression() : 
{
	Expression expr = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		(
			try {			  
		  		LOOKAHEAD(2) expr = IdentifierOrConstant()
	  			|
	  			<LEFTPAREN> expr = Expression() <RIGHTPAREN>
	  		} catch (DMLParseException e) {				runningList.add(e);
	  		}
	   	)
		{
			// position info for expression already set
			if (runningList.size() > 0)
				throw runningList;
			return expr;
		} 
	} catch (Exception e) {
		if (e != runningList)
			runningList.add(e);
			throw runningList;
	}
}


Identifier IdentifierOrConstant() :
{
 	Identifier id = null;
 	Token t1 = null;
 	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try {
	  
		(

			(t1 = <DOLLAR_ID> | t1 = <DOLLAR_ID_POS>)
			{
		
				///////// BEGIN handle variable param /////////////////////////////
	
				String argVal = commandArgs.get(t1.image);
	
				if (argVal == null){				  	runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(t1.beginLine, t1.beginColumn) + " value for " + t1.image + " is undefined "));
					throw runningList;
				}				
				try {
				  	// try to assign to long value
					Long longVal = new Long(argVal);
					id = new IntIdentifier(longVal);
					id.setAllPositions(this.getFilename(), t1.beginLine, t1.beginColumn, t1.beginLine, t1.beginColumn);
					
				} catch(Exception e1){
				  	try {
				  	  	// try to assign to double value
				  	  	Double doubleVal = new Double(argVal);
				  	  	id = new DoubleIdentifier(doubleVal);
				  	  	id.setAllPositions(this.getFilename(), t1.beginLine, t1.beginColumn, t1.beginLine, t1.beginColumn);
				  	  
				  	} catch (Exception e2) {
	
						// try to assign to boolean value
						if (argVal.equalsIgnoreCase("true") || argVal.equalsIgnoreCase("false")){   
							Boolean boolVal = new Boolean(argVal);
				  	  		id = new BooleanIdentifier(boolVal);
				  	  		id.setAllPositions(this.getFilename(),t1.beginLine, t1.beginColumn, t1.beginLine, t1.beginColumn);
						}
						else {
						  	// try to assign to string value
							id = new StringIdentifier(argVal);
							id.setAllPositions(this.getFilename(), t1.beginLine, t1.beginColumn, t1.beginLine, t1.beginColumn);
						}	
	
				  	} // end catch e2
					  						  	 
				} // end catch e1
		
		   	}
			///////// END handle variable param ///////////////
					
			|

			try {
				id = Identifier()
				|
				id = Constant()
			} catch (DMLParseException e) {				runningList.add(e);
			}
	
		)
		{ 
			if (runningList.size() > 0) {
				throw runningList;
			} else {
				return id;
			} 
		}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


ConstIdentifier Constant() :
{
	Token t = null;
	Boolean minus = false;
	ConstIdentifier id = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{  
	try {
	   (
	      LOOKAHEAD(2) id = IntConstant()
	      | id = DoubleConstant()
	      | id = BooleanConstant()
	      | id = StringConstant()
	    )
	 	{
	 	  	// position for id already set
	  		return id; 
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


IntIdentifier IntConstant() :
{
	Token t = null;
	Boolean minus = false;
	IntIdentifier id = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		(<MINUS > {minus = true;})?
	 	(
	  		t = <INTEGER>
	  		{
	     		long intval = Long.parseLong(t.image);
	     		if (minus)
	     			intval = -intval;
	   			id = new IntIdentifier(intval);
	  		}
	 	)
	 	{
			id.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn, t.endLine, t.endColumn);
	 		return id; 
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


DoubleIdentifier DoubleConstant() :
{
	Token t;
	Boolean minus = false;
	DoubleIdentifier id = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try	{
		(<MINUS > {minus = true;})?
	 	(
			t = <DOUBLE>
			{
	      		Double doubleval = Double.parseDouble(t.image);
	      		if (minus)
	      		{
	        		doubleval = -doubleval;
	      		}
	   			id = new DoubleIdentifier(doubleval);
	  		}
	 	)
	 	{ 
			id.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn,  t.endLine, t.endColumn);
	 		return id; 
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


BooleanIdentifier BooleanConstant() :
{
	Token t;
	BooleanIdentifier id = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
	    (
	  		(t = <TRUE> | t =<FALSE>)
	  		{
	   			id = new BooleanIdentifier(Boolean.parseBoolean(t.image));
	   			id.setDimensions(0,0);
				id.computeDataType();
				id.setValueType(ValueType.BOOLEAN);
	  		}
	 	)
	 	{
			id.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn,  t.endLine, t.endColumn);
	 		return id; 
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}
	

StringIdentifier StringConstant() :
{
	Token t = null;
	StringIdentifier id = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
	    (
	  		(t =<DBLQUOTE_STRING_LITERAL>){ id = new StringIdentifier(dequoteStr('\"',t.image)); }
	 	)
	 	{ 
			id.setAllPositions(this.getFilename(), t.beginLine, t.beginColumn,  t.endLine, t.endColumn);
	 		return id; 
	 	}
	} catch (Exception e){
		if (e != runningList)
			runningList.add(e);
		throw runningList;
	}
}


DataIdentifier Identifier() :
{
	Token t = null, tD = null;
	String idNameStr = null;
	Token tNamespace = null;
	DataIdentifier id = null;
	FunctionCallIdentifier functCall = null;
	ArrayList<ArrayList<Expression>> exprListList = null;
	int blp = 0, bcp = 0, elp = 0, ecp = 0;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{	try {   	
		[
			LOOKAHEAD(4)tNamespace = <ID>
			{
				blp=tNamespace.beginLine;
				bcp=tNamespace.beginColumn;
				elp =tNamespace.endLine;
				ecp = tNamespace.endColumn;
			}
			<COLON><COLON>
		]
		
		(t = <ID> | tD = <DOLLAR_ID> | tD = <DOLLAR_ID_POS>)
		
		{
			if (tD != null && tNamespace != null){
				runningList.add(new DMLParseException(this.getFilename(), printErrorLocation(tNamespace.beginLine, tNamespace.beginColumn) + "cannot use namespaces with passed arguments"));
				throw runningList;
			}

			if (tNamespace == null ){
			  	if (t != null){			  		blp=t.beginLine;
					bcp=t.beginColumn;
					elp=t.endLine;
					ecp=t.endColumn;
				} else {
				  	blp=tD.beginLine;
					bcp=tD.beginColumn;
					elp=tD.endLine;
					ecp=tD.endColumn;
				}
			}

		  	if (t != null)
				idNameStr = t.image;
			else 
				idNameStr = tD.image;			
		}
		
		(LOOKAHEAD(2)
			try {
			  				functCall = FunctionCall()
				| 				exprListList = ReadIndexList()

			} catch (DMLParseException e){
				runningList.add(e);
			}
		)?
			
		{
			id = new DataIdentifier(idNameStr);
  
			if (functCall != null) {

				// CASE: no namespace -- check if built-in functions
				if ( tNamespace == null) {
  
					// check if passed function name is a (non-parameterized) built-in function.
					BuiltinFunctionExpression bife = BuiltinFunctionExpression.getBuiltinFunctionExpression(t.image, functCall.getParamExprs());
					if (bife != null){
						if (runningList.size() > 0){
							throw runningList;
						} else {
						  	bife.setAllPositions(this.getFilename(), blp, bcp, functCall.getEndLine(), functCall.getEndColumn());							return bife;
						}
					}
	
					// check if passed function name is a parameterized built-in function.
					ParameterizedBuiltinFunctionExpression pbife = ParameterizedBuiltinFunctionExpression.getParamBuiltinFunctionExpression(t.image, functCall.getParamExprs());
					if (pbife != null){
						
						if (runningList.size() > 0)
							throw runningList;
						else {
							pbife.setAllPositions(this.getFilename(), blp, bcp, functCall.getEndLine(), functCall.getEndColumn());						  	return pbife;
						}
					}
					
					// check if passed function name is a data operation built-in function.
					DataExpression dbife = null;

					try {					  dbife = DataExpression.getDataExpression(t.image, functCall.getParamExprs(), t.beginLine, t.beginColumn);
					} catch (DMLParseException e){						runningList.add(e);
					}
				
					if (dbife != null){						
						if (runningList.size() > 0)
							throw runningList;
						else {							dbife.setAllPositions(this.getFilename(), blp, bcp, functCall.getEndLine(), functCall.getEndColumn());
							return dbife;
						}
					}
				}

				// handle UDF function call
				if (runningList.size() > 0) {
					throw runningList;
				} else {				  
					String namespaceName = (tNamespace == null) ? DMLProgram.DEFAULT_NAMESPACE : tNamespace.image;
	    			functCall.setFunctionNamespace(namespaceName);						
	    			functCall.setFunctionName(idNameStr);

					// set position information
					functCall.setAllPositions(this.getFilename(), blp, bcp, functCall.getEndLine(), functCall.getEndColumn());
				
	   				return functCall;
	   			}
			}
		
			else if (exprListList != null){

				IndexedIdentifier iid = null;
				try {
				  	if (id != null) {
				  		iid = new IndexedIdentifier(id.getName(), false, false);
						iid.setIndices(exprListList);
					}
				} catch (DMLParseException e) {
		  			runningList.add(e);
				}
		
				// set position information
				if (iid != null && exprListList != null)
					iid.setAllPositions(this.getFilename(), blp, bcp, exprListList);

				if (runningList.size() > 0)
					throw runningList;
		   		return iid;

			} else {
				// set position information
				if (id != null)
					id.setAllPositions(this.getFilename(), blp, bcp, elp, ecp);

				if (runningList.size() > 0)
					throw runningList;
				return id;
			}
 		}

	} catch (Exception e){		if (e != runningList)
			runningList.add(new DMLParseException(getFilename(), e));
		throw runningList;  	}
}


Statement OutputStatement() :
{
	Expression fn = null;
	Expression t2 = null;
	Statement os = null;
	Token t1 = null, tStart = null, tEnd = null;
	FunctionCallIdentifier fci = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}
{
	try {
		(			tStart = <PRINT> <LEFTPAREN>
			try {				t2 = Expression()
			} catch (DMLParseException e){				runningList.add(e);
			}
			tEnd = <RIGHTPAREN>  
			{				if (runningList.size() > 0) {
					throw runningList;
				} else {					os  = new PrintStatement(t2);
					os.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, tEnd.beginLine, tEnd.beginColumn);
					return os;
				}
			}
		)
		
		|
			
		( 
			(tStart = <WRITEMATRIX> | tStart = <WRITEMM> | tStart = <WRITE_CSV>)
			fci = FunctionCall()		
			{
				try {
					os = new OutputStatement(tStart.image, fci);
					os.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, fci.getEndLine(), fci.getEndColumn());
				} catch (DMLParseException e) {					runningList.add(e);
				}
				if (runningList.size() > 0)
					throw runningList;
		
				return os;
			}
		)
		
	} catch (Exception e){
		if (e != runningList)
			runningList.add(new DMLParseException(getFilename(), e));
		throw runningList;  
	}
}

FunctionCallIdentifier FunctionCall():
{
	Expression expr = null;
	FunctionCallIdentifier functCall = null;
	ArrayList<ParameterExpression> paramExprs = new ArrayList<ParameterExpression>();
	Token tStart = null, tEnd = null, t1 = null, commaToken = null;
	DMLParseException runningList = new DMLParseException(this.getFilename());
}

{
	try {
	  
		tStart = <LEFTPAREN>	  
		(
			{ commaToken = null; }
			( commaToken = <COMMA>)? (LOOKAHEAD(2) t1= <ID> <ASSIGN>)?
	
				try {				  expr = Expression()
				} catch(DMLParseException e) {
				  	runningList.add(e);
				}				  
	
			{
				String paramName = (t1 != null) ? t1.image : null;
				paramExprs.add(new ParameterExpression(paramName, expr));
				t1 = null;
	
				int exprCount = paramExprs.size();
				if (exprCount == 1 && commaToken != null)
				  	runningList.add(new DMLParseException(this.getFilename(), expr.printErrorLocation() + "should not have comma before first function call parameter"));  
				if (exprCount != 1 && commaToken == null)
					runningList.add(new DMLParseException(this.getFilename(), expr.printErrorLocation() + "missing comma before function call parameter " + exprCount));
			}
		)*
		tEnd = <RIGHTPAREN>
			
		{
			functCall = new FunctionCallIdentifier(paramExprs);
			functCall.setAllPositions(this.getFilename(), tStart.beginLine, tStart.beginColumn, tEnd.beginLine, tEnd.beginColumn);
			if (runningList.size() > 0)
				throw runningList;
			return functCall;
		}     
	} catch (Exception e){
		if (e != runningList)
			runningList.add(new DMLParseException(getFilename(), e));
		throw runningList;  
	}
}

void RelationalOp() :
{}
{
	(<LESS> | <GREATER> | <GREATEREQUAL> | <LESSEQUAL> | <EQUAL> | <NOTEQUAL>)
}

/*
Statement MetaLearningStatement() :
{
	FunctionCallIdentifier 	inputs 					= null;
	HashMap<String,String>	partitionParams			= null; 
	FunctionCallIdentifier 	partitionOutputs 		= null;
	DataIdentifier 			trainFunctionCall 		= null;
	FunctionCallIdentifier 	trainFunctionOutputs 	= null;
	DataIdentifier 			testFunctionCall		= null;
	FunctionCallIdentifier 	testFunctionOutputs 	= null;
	DataIdentifier 			aggFunctionCall 		= null;
	DataIdentifier 			aggFunctionOutputs 		= null;

	Token 	aggfunc 	= null;
	Token	tPartition 	= null, tAs_1 = null;
	Token	tTrain 		= null, tAs_2 = null;
	Token   tTest 		= null, tAs_3 = null;
	Token	tAgg 		= null, tAs_4 = null;
	
}
{
	"crossval"  inputs = FunctionCall()
 	"partition" partitionParams = ReadGenericParamList() "as" partitionOutputs		= FunctionCall()
	"train"		trainFunctionCall = Identifier() 		 "as" trainFunctionOutputs 	= FunctionCall()
 	"test"		testFunctionCall  = Identifier() 		 "as" testFunctionOutputs  	= FunctionCall()
 	"aggregate" aggFunctionCall   = Identifier()  		 "as" aggFunctionOutputs 	= FunctionCall()

 	{
 	  	CVStatement cvs = new CVStatement();
 	  	cvs.set_inputs(inputs);
		cvs.set_partitionParams(partitionParams);
		cvs.set_partitionOutputs(partitionOutputs);
		cvs.set_trainFunctionCall((FunctionCallIdentifier)trainFunctionCall);
		cvs.set_trainFunctionOutputs(trainFunctionOutputs);
		cvs.set_testFunctionCall((FunctionCallIdentifier) testFunctionCall);
		cvs.set_testFunctionOutputs(testFunctionOutputs);
		cvs.set_aggFunctionCall((Identifier)aggFunctionCall);
		cvs.set_aggFunctionOutputs((FunctionCallIdentifier)aggFunctionOutputs); 
		return cvs;
 	}
 
}
*/
/*
ELStatement ELStatement() :
{
	Token t = null, tOn = null, tPartition = null, tTrain = null, tTest = null;
	Token tAs_1 = null, tAs_2 = null, tAs_3 = null;
	String eNameStr = null; 
	CVStatement.AGG agg = null ;

	HashMap<String,String> partitionParams = null;
	ArrayList<String> dataList = new ArrayList<String>();
	String trainFunctionName = null, testFunctionName = null ;

  	ArrayList<String> partitionOutputs = new ArrayList<String>(), trainFunctionParams = new ArrayList<String>(),
		trainFunctionOutputs = new ArrayList<String>(), testFunctionParams = new ArrayList<String>(),
		testFunctionOutputs = new ArrayList<String>(), errorAggFunctionParams = new ArrayList<String>(),
		errorAggFunctionOutputs = new ArrayList<String>();

}
{
	<BUILD_ENSEMBLE> //t = <ID> { eNameStr = t.image; } tOn = <ID> dataList = ReadList()
 	//tPartition = <ID> partitionParams = ReadGenericParamList() 												  tAs_1	= <ID> partitionOutputs = ReadList()
	//tTrain = <ID> t =  {  trainFunctionName = t.image;  } trainFunctionParams = ReadList()  			  tAs_2 = <ID> trainFunctionOutputs = ReadList()
	//[LOOKAHEAD(2) tTest = <ID>  t = <ID> { testFunctionName  = t.image;  } testFunctionParams  = ReadList()   tAs_3 = <ID> testFunctionOutputs  = ReadList()]

 	{
		// verify that "as" tokens have correct value
//		if (!"on".equals(tOn)) throw new ParseException(printErrorLocation(tOn.beginLine, tOn.beginColumn) + "incorrect syntax for build ensemble -- should be \"build ensemble <name> on (data list)\"");
//		if (!"as".equals(tAs_1)) throw new ParseException(printErrorLocation(tAs_1.beginLine, tAs_1.beginColumn) + "incorrect syntax for build ensemble -- should be \"(partition params) as (partition outputs)\"");
//		if (!"as".equals(tAs_2)) throw new ParseException(printErrorLocation(tAs_2.beginLine, tAs_2.beginColumn) + "incorrect syntax for build ensemble -- should be \"(error agg params) as (error agg outputs)\"");
//		if (tAs_3 != null &&  !"as".equals(tAs_3)) throw new ParseException(printErrorLocation(tAs_3.beginLine, tAs_3.beginColumn) + "incorrect syntax for build ensemble -- should be \"(error agg params) as (error agg outputs)\"");
	
//		MetaLearningFunctionParameters params = new MetaLearningFunctionParameters(
//				trainFunctionName, trainFunctionParams, trainFunctionOutputs, 
//				testFunctionName,  testFunctionParams,  testFunctionOutputs, 
//				partitionOutputs, 
//				agg, errorAggFunctionParams, errorAggFunctionOutputs); 
//
//		return null; //new ELStatement(eNameStr, dataList, partitionParams, params) ;
//	}
//}
//*/
/*
ELUseStatement ELUseStatement() :
{
	Token t = null, aggfunc = null, tOn = null, tTest = null, tAgg = null;
	Token tAs_1 = null, tAs_2 = null;
  	String eNameStr = null;
 	HashMap<String,String> partitionParams = null;
  	String trainFunctionName = null, testFunctionName = null ;

	ArrayList<String> dataList = new ArrayList<String>(), partitionOutputs = new ArrayList<String>(),
    trainFunctionParams = new ArrayList<String>(),trainFunctionOutputs = new ArrayList<String>(),
    testFunctionParams = new ArrayList<String>(), testFunctionOutputs = new ArrayList<String>(),
    errorAggFunctionParams = new ArrayList<String>(), errorAggFunctionOutputs = new ArrayList<String>();
 
}
{
	<USE_ENSEMBLE> //t = <ID> { eNameStr = t.image; } tOn = <ID> dataList = ReadList()
   // tTest = <ID>  t = <ID> { testFunctionName  = t.image;  } testFunctionParams  = ReadList() tAs_1 = <ID> testFunctionOutputs     = ReadList()
 //	tAgg  = <ID> (aggfunc = <ID>) errorAggFunctionParams = ReadList() 						  tAs_2 = <ID> errorAggFunctionOutputs = ReadList()

	{
//		CVStatement.AGG agg = null ;
//		if("sum".equals(aggfunc.image))
//			agg = CVStatement.AGG.sum ;
//		else if("avg".equals(aggfunc.image))
//			agg = CVStatement.AGG.avg ;

		// verify that "as" tokens have correct value
//		if (!"on".equals(tOn))   throw new ParseException(printErrorLocation(tOn.beginLine, tOn.beginColumn) + "incorrect syntax for use ensemble -- should be \"use ensemble <name> on (data list)\"");
//		if (!"as".equals(tAs_1)) throw new ParseException(printErrorLocation(tAs_1.beginLine, tAs_1.beginColumn) + "incorrect syntax for use ensemble -- should be \"(test params) as (test outputs)\"");
//		if (!"as".equals(tAs_2)) throw new ParseException(printErrorLocation(tAs_2.beginLine, tAs_2.beginColumn) + "incorrect syntax for use ensemble -- should be \"(error agg params) as (error agg outputs)\"");
	
//		MetaLearningFunctionParameters params = new MetaLearningFunctionParameters(
//				trainFunctionName, trainFunctionParams, trainFunctionOutputs, 
//     	  		testFunctionName,  testFunctionParams,  testFunctionOutputs, 
//      		partitionOutputs, 
//       		agg, errorAggFunctionParams, errorAggFunctionOutputs); 

		return null; //new ELUseStatement(eNameStr, dataList, partitionParams, params) ;
 	}

}
*/