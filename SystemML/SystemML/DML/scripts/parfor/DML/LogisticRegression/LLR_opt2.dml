# internal parameters
tol = 0.001
eta0 = 0.0001
eta1 = 0.25
eta2 = 0.75
sigma1 = 0.25
sigma2 = 0.5
sigma3 = 4.0
psi = 0.1 

maxiter = 1000 
maxinneriter = 1000

# read training data files
X = read("./mboehm/exp/in/x")
y = read("./mboehm/exp/in/y")
N = nrow(X)
D = ncol(X) 

# read parameter settings
params = read("./mboehm/exp/in/params");
numModels = nrow(params);

# transpose training data
tX = t(X);

# initialize variable to store computed models
wModels = Rand( rows=D, cols=numModels, min=0, max=0 );

parfor( i in 1:numModels ) 
{
   # retrieve regularizer and weights from parameter settings	
   regul = castAsScalar( params[i,1] );
   wt = castAsScalar( params[i,2] );
   
   #print("ESTIMATE model regul="+regul+", wt="+wt);
   
   C = regul * (ppred(y, 1, "==") + wt * ppred(y,-1,"=="));
   
   #initialize w
   w = Rand(rows=D, cols=1, min=0.0, max=0.0);
   e = Rand(rows=1, cols=1, min=1.0, max=1.0); 

   # matrix multiply training data with weight
   o = X %*% w
   logistic = 1.0/(1.0 + exp( -y * o))
   
   # compute objective and gradient
   obj = 0.5 * t(w) %*% w + sum(-C*log(logistic))
   grad = w + tX %*% (C*(logistic - 1)*y)
   logisticD = logistic*(1-logistic)
   delta = sqrt(sum(grad*grad))
   
   # number of iterations
   iter = 0
   
   # starting point for CG
   zeros_D = Rand(rows = D, cols = 1, min = 0.0, max = 0.0);
   # VS: change
   zeros_N = Rand(rows = N, cols = 1, min = 0.0, max = 0.0);
   
   # boolean for convergence check
   
   converge = (delta < tol) | (iter > maxiter)
   norm_r2 = sum(grad*grad)
   
   # VS: change
   norm_grad = sqrt(norm_r2)
   norm_grad_initial = norm_grad
   
   alpha = t(w) %*% w
   alpha2 = alpha
   
   dummy = Rand(rows=1, cols=1, min=1, max=1);
   
   #while outer loop not converged
   while(!converge) 
   {
      norm_grad = sqrt(sum(grad*grad))
      
      print("-- Outer Iteration = " + iter)
      objScalar = castAsScalar(obj)
      #print("     Iterations = " + iter + ", Objective = " + objScalar + ", Gradient Norm = " + norm_grad)
      
      # SOLVE TRUST REGION SUB-PROBLEM
      s = zeros_D
      os = zeros_N
      r = -grad
      d = r
      inneriter = 0
      innerconverge = ( sqrt(sum(r*r)) <= psi * norm_grad) 

      # while inner loop not converged
      while (!innerconverge) 
      {
          inneriter = inneriter + 1
          norm_r2 = sum(r*r)
          od = X %*% d
          Hd = d + (tX %*% (C*logisticD*od))
          alpha_deno = t(d) %*% Hd 
          alpha = norm_r2 / alpha_deno
         
          s = s + castAsScalar(alpha) * d
          os = os + castAsScalar(alpha) * od
        
          sts = t(s) %*% s
          delta2 = delta*delta 
          stsScalar = castAsScalar(sts)
          
          shouldBreak = false;  # to mimic "break" in the following 'if' condition
          if (stsScalar > delta2) 
          {
              #print("      --- cg reaches trust region boundary")
              s = s - castAsScalar(alpha) * d
              os = os - castAsScalar(alpha) * od
              std = t(s) %*% d
              dtd = t(d) %*% d
              sts = t(s) %*% s
              rad = sqrt(std*std + dtd*(delta2 - sts))
              stdScalar = castAsScalar(std)
              if(stdScalar >= 0) {
               tau = (delta2 - sts)/(std + rad)
              } 
              else {
               tau = (rad - std)/dtd
              }
                 
              s = s + castAsScalar(tau) * d
              os = os + castAsScalar(tau) * od
              r = r - castAsScalar(tau) * Hd
              
              #break
              shouldBreak = true;
              innerconverge = true;
          } 
       
          if (!shouldBreak) 
          {
              r = r - castAsScalar(alpha) * Hd
              old_norm_r2 = norm_r2 
              norm_r2 = sum(r*r)
              beta = norm_r2/old_norm_r2
              d = r + beta*d
              innerconverge = (sqrt(norm_r2) <= psi * norm_grad) | (inneriter > maxinneriter)
          }
        }  
    
        #print("      --- Inner CG Iteration =  " + inneriter)
        # END TRUST REGION SUB-PROBLEM

        # compute rho, update w, obtain delta
        gs = t(s) %*% grad
        qk = -0.5*(gs - (t(s) %*% r))
        
        wnew = w + s 
        onew = o + os
        logisticnew = 1.0/(1.0 + exp(-y * onew ))
        objnew = 0.5 * t(wnew) %*% wnew + sum(-C*log(logisticnew))
        
        actred = (obj - objnew)
        actredScalar = castAsScalar(actred)
        rho = actred / qk
        qkScalar = castAsScalar(qk)
        rhoScalar = castAsScalar(rho);
        snorm = sqrt(sum( s * s ))
        #print("     Actual    = " + actredScalar)
        #print("     Predicted = " + qkScalar)
        
        if (iter==0) 
        {
           delta = min(delta, snorm)
        }

        alpha2 = objnew - obj - gs
        alpha2Scalar = castAsScalar(alpha2)

        if (alpha2Scalar <= 0) 
        {
           alpha = sigma3*e
        } else {
           ascalar = max(sigma1, -0.5*castAsScalar(gs)/alpha2Scalar)  
           alpha = ascalar*e
        }
       
        if (rhoScalar > eta0) 
        {
           w = wnew
           o = onew
           grad = w + tX %*% (C*(logisticnew - 1) * y )
           norm_grad = sqrt(sum(grad*grad))
           logisticD = logisticnew * (1 - logisticnew)
           obj = objnew 
        } 
       
        alphaScalar = castAsScalar(alpha)

        if (rhoScalar < eta0)
        {
           delta = min(max( alphaScalar , sigma1) * snorm, sigma2 * delta )
        } else {
           if (rhoScalar < eta1)
           {
              delta = max(sigma1 * delta, min( alphaScalar  * snorm, sigma2 * delta))
           } else { 
              if (rhoScalar < eta2) 
              {
                 delta = max(sigma1 * delta, min( alphaScalar * snorm, sigma3 * delta))
              } else {
                 delta = max(delta, min( alphaScalar * snorm, sigma3 * delta))
              }
           }
        } 
        
        o2 = y * o
        correct = sum(ppred(o2, 0, ">"))
        accuracy = correct*100.0/N 
        iter = iter + 1

        converge = (norm_grad < tol) | (iter > maxiter)
       
        #print("     Delta =  " + delta)
        #print("     Training Accuracy =  " +  accuracy)
        #print("     Correct =  " + correct)
        #print("     OuterIter =  " + iter)
        #print("     Converge =  " + converge)

   } # OuterWhile
   
   wModels[,i] = w; 

} #ParFor

write(wModels, "./mboehm/exp/out/WModels");