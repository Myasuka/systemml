#-------------------------------------------------------------
# IBM Confidential
# OCO Source Materials
# (C) Copyright IBM Corp. 2010, 2014
# The source code for this program is not published or
# otherwise divested of its trade secrets, irrespective of
# what has been deposited with the U.S. Copyright Office.
#-------------------------------------------------------------
# 
# This script performs Principal Component Analysis (PCA) on the given input data.
#
# INPUT PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME   TYPE   DEFAULT  MEANING
# ---------------------------------------------------------------------------------------------
# INPUT  String ---      Location to read the matrix A of feature vectors
# K      Int    ---      Required dimension of the new vector space constructed from eigen vectors
# ZSCORE Int    ---      Indicates whether or not to z-score input data (0 or 1)
# OFMT   String ---      Output data format
# OUTPUT String ---      Location to write output matrices (covariance matrix, new basis vectors, 
#                           and data projected onto new basis vectors)
# ---------------------------------------------------------------------------------------------


jlpk_eigen = externalFunction(Matrix[Double] A) return (Matrix[Double] evec, Matrix[Double] eval) implemented in 
        (classname="mludfs.EigenWrapper", exectype="mem")

A = read($INPUT);
K = ifdef($K, ncol(A));
zscore = ifdef($ZSCORE, 0);
ofmt = ifdef($OFMT, "text")

N = nrow(A);
D = ncol(A);

# perform z-scoring (centering and scaling)
if (zscore == 1) {
    cm = colMeans(A);
    cvars = (colSums (A^2) - N*(cm^2))/(N-1);
    Azscored = t((t(A)-t(cm))/t(sqrt(cvars)));
    #write(Azscored, $OUTPUT+"/Az.mtx", format=ofmt);
    A = Azscored;
}

# co-variance matrix 
mu = colSums(A)/N;
C = (t(A) %*% A)/(N-1) - (N/(N-1))*t(mu) %*% mu;
write(C, $OUTPUT+"/covar.mtx", format=ofmt);


# compute eigen vectors and values
#[evalues, evectors] = eigen(C);
[evalues, evectors] = jlpk_eigen(C);


# eigen() and jlpk_eigen() produces eigen values in increasing order. Rearrange the rows, so that eigen values are in the decreasing order
# 1^st row becomes D^th row; 2^nd row becomes (D-1)^th row; ... ; D^th row becomes 1^st row
permutation = table(seq(1,D),seq(D,1))
evalues = permutation %*% evalues;
evectors = permutation %*% evectors 


# select three dominant eigen vectors 
nvec = ncol(evectors);
if ( K == nvec ) {
    eval_dominant = evalues;
    evec_dominant = evectors;
}
else {
    eval_dominant = evalues[1:K, 1];
    evec_dominant = evectors[,1:K];
}
write(eval_dominant, $OUTPUT+"/dominant.eigen.values", format=ofmt);
write(evec_dominant, $OUTPUT+"/dominant.eigen.vectors", format=ofmt);

# Construct new data set by treating computed dominant eigenvectors as the basis vectors
newA = A %*% evec_dominant;
write(newA, $OUTPUT+"/new.data", format=ofmt);

