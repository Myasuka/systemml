/*
 *
 * For a given pair of attribute sets, compute bivariate statistics between all attribute pairs 
 *   Given, S_1 = {A_11, A_12, ... A_1m} and S_2 = {A_21, A_22, ... A_2n} 
 *          compute bivariate stats for m*n pairs (A_1i, A_2j), (1<= i <=m) and (1<= j <=n)
 *
 * Seven inputs:  
 *    $1) D  - input data
 *    $2) S1 - First attribute set {A_11, A_12, ... A_1m}
 *    $3) S2 - Second attribute set {A_21, A_22, ... A_2n}
 *    $4) K1 - kind for attributes in S1 
 *    $5) K2 - kind for attributes in S2
 *             kind=1 for scale, kind=2 for nominal, kind=3 for ordinal
 *    $7) numPairs - total number of pairs (m*n)
 *    $8) maxC - maximum number of categories in any categorical attribute
 * 
 * One output:    
 *    $6) output directory in which following four statistics files are created
 *        + bivar.stats - matrix with all 11 bivariate statistics computed for different attribute pairs
 *                         1   2       3   4     5          6          7      8      9      10      11      12   13 14   15   16    17
 *                        (R, (chi-sq, df, pval, cramersv), (spearman, Gamma, Tau-a, Tau-b, p_Tau-b Tau-c), Eta, F, df1, df2, pval, Count)
 *        + categorical.counts - 
 *        + categorical.means - 
 *        + categorical.variances - 
 *          -> Values in these three matrices are applicable only for scale-categorical attribute pairs. 
 *          k^th column in these matrices denote the attribute pair (A_1i,A_2j) where i*j = k.
 */

D = read($1);  # input data set
S1 = read($2); # attribute set 1
S2 = read($3); # attribute set 2
K1 = read($4); # kind for attributes in S1
K2 = read($5); # kind for attributes in S2
numPairs = $7; # number of attribute pairs (|S1|*|S2|)
maxC = $8;     # max number of categories in any categorical attribute

s1size = ncol(S1);
s2size = ncol(S2);
  
# R, chisq, df, pvalue, cramers, spearman, eta, anovaf, df1, df2, pval
numstats = 17;
basestats = matrix(0, rows=numstats, cols=numPairs);
  
max_kind = max (max(K1), max(K2));
  
cat_counts = matrix(0, rows=maxC, cols=numPairs);
cat_means = matrix(0, rows=maxC, cols=numPairs);
cat_vars = matrix(0, rows=maxC, cols=numPairs);
  
parfor( i in 1:s1size, mode=REMOTE_MR, check=0, opt=CONSTRAINED)
#for( i in 1:s1size)
{
  a1 = castAsScalar(S1[1,i]);
  k1 = castAsScalar(K1[1,i]);
  A1 = D[,a1];
    
  for( j in 1:s2size)
  {
    pairID = (i-1)*s2size+j; 
    a2 = castAsScalar(S2[1,j]);
    k2 = castAsScalar(K2[1,j]);
    A2 = D[,a2];
      
    if (k1 == k2)
    {
      if (k1 == 1)
      {
	# scale-scale
        print("[" + i + "," + j + "] scale-scale");
        r = bivar_ss(A1,A2);   
        basestats[1,pairID] = r;
      }
      else {
          if (k1 == 2)
          {
            # nominal-nominal 
            print("[" + i + "," + j + "] categorical-categorical");

            [chisq, df, pval, cramersv, cnt]  = bivar_cc(A1,A2);
            basestats[2,pairID] = chisq;
            basestats[3,pairID] = df;
            basestats[4,pairID] = pval;
            basestats[5,pairID] = cramersv;
            basestats[17,pairID] = cnt;
          } 
          else {
            # ordinal-ordinal
            print("[" + i + "," + j + "] ordinal-ordinal");
            [sp, gm, tau_a, tau_b, p_tau_b, tau_c, cnt] = bivar_oo(A1,A2);
            basestats[6,pairID] = sp;
            basestats[7,pairID] = gm;
            basestats[8,pairID] = tau_a;
            basestats[9,pairID] = tau_b;
            basestats[10,pairID] = p_tau_b;
            basestats[11,pairID] = tau_c;
            basestats[17,pairID] = cnt;
          }
      }
    } #k1==k2
    else
    {
      if (k1 == 1 | k2 == 1)
      {
	# Scale-nominal/ordinal
        print("[" + i + "," + j + "] scale-categorical");
					
        if ( k1 == 1 )
        {
          [eta,f, df1, df2, pval, counts, means, vars] = bivar_sc(A1,A2);
        }
	else
        {
          [eta,f, df1, df2, pval, counts, means, vars] = bivar_sc(A2,A1);
        }

        basestats[12,pairID] = eta;
        basestats[13,pairID] = f;
        basestats[14,pairID] = df1;
        basestats[15,pairID] = df2;
        basestats[16,pairID] = pval;

        cat_counts[,pairID] = counts;
        cat_means[,pairID] = means;
        cat_vars[,pairID] = vars; 
      }
      else
      {
	# nominal-ordinal or ordinal-nominal
        print("[" + i + "," + j + "] categorical-categorical");
        [chisq, df, pval, cramersv, cnt]  = bivar_cc(A1,A2);
        basestats[2,pairID] = chisq;
        basestats[3,pairID] = df;
        basestats[4,pairID] = pval;
        basestats[5,pairID] = cramersv;
        basestats[17,pairID] = cnt;
      }
    } #k1!=k2
  } #inner parfor
} #outer parfor

write(basestats, $6 + "/bivar.stats");
	
# Write category-wise stats only when there exist categorical attributes
if ( max_kind > 1 )
{
  write(cat_counts, $6 + "/category.counts");
  write(cat_means, $6 + "/category.means");
  write(cat_vars, $6 + "/category.variances");
}

# -----------------------------------------------------------------------------------------------------------

table = function(Matrix[Double] A, Matrix[Double] B) return (Matrix[Double] ctab) {
  # Contingency Table
  FF = ctable(A,B);

  nrFF = nrow(FF)
  ncFF = ncol(FF)

  if(nrFF > 0 & ncFF > 0){
    # Remove empty rows and columns, which otherwise lead to NaN values
    tmp = removeEmpty(target=FF, margin="rows"); 
    ctab = removeEmpty(target=tmp, margin="cols");
  }else{
    ctab = FF
  }
}

# -----------------------------------------------------------------------------------------------------------

bivar_cc = function(Matrix[Double] A, Matrix[Double] B) return (Double chisq, Double df, Double pval, Double cramersv, Double cnt)
{

  # Contingency Table
  F = table(A,B);
  
  if (nrow(F) == 1 | ncol(F) == 1) {
      chisq = -1.0;
      df = -1.0;
      pval = -1.0;
      cramersv = -1.0;
      cnt = 0.0;
      print("Categorical-Categorical: skipping");
  }
  else {
      # Chi-Squared
      W = sum(F);
      r = rowSums(F);
      c = colSums(F);
      E = (r %*% c)/W;
      T = (F-E)^2/E;
      chi_squared = sum(T);
      
      # compute p-value
      degFreedom = (nrow(F)-1)*(ncol(F)-1.0);
      #if (0 ==0) 
      #{
      #   print ("!!!! chi_squared = " + chi_squared + "  degFreedom = " + degFreedom);
      #}
      pValue = 1 - cumulativeProbability(target=chi_squared, dist="chisq", df=degFreedom);

      # Cramer's V
      R = nrow(F);
      C = ncol(F);
      q = min(R,C);
      cramers_v = sqrt(chi_squared/(W*(q-1)));

      # Assign return values
      chisq = chi_squared;
      df = degFreedom;
      pval = pValue;
      cramersv = cramers_v;
      cnt = W;
  }

}

# -----------------------------------------------------------------------------------------------------------

bivar_ss = function(Matrix[Double] X, Matrix[Double] Y) return (Double R) {

  # Unweighted co-variance
  covXY = cov(X,Y);

  # compute standard deviations for both X and Y by computing 2^nd central moment
  W = nrow(X);
  m2X = centralMoment(X,2);
  m2Y = centralMoment(Y,2);
  sigmaX = sqrt(m2X * (W/(W-1.0)) );
  sigmaY = sqrt(m2Y * (W/(W-1.0)) );

  # Pearson's R
  R = covXY / (sigmaX*sigmaY);
}

# -----------------------------------------------------------------------------------------------------------

# Y points to SCALE variable
# A points to CATEGORICAL variable

bivar_sc = function(Matrix[Double] Y, Matrix[Double] A) return (Double Eta, Double AnovaF, Double pVal, Double df1, Double df2, Matrix[Double] CFreqs, Matrix[Double] CMeans, Matrix[Double] CVars ) {

    # mean and variance in target variable
  W = nrow(A);
  my = mean(Y);
  varY = centralMoment(Y,2) * W/(W-1.0)

  # category-wise (frequencies, means, variances)
  CFreqs = groupedAggregate(target=Y, groups=A, fn="count"); 
  CMeans = groupedAggregate(target=Y, groups=A, fn="mean");
  CVars  = groupedAggregate(target=Y, groups=A, fn="variance");

  oldrows = nrow(CFreqs);
  CFreqs_old = CFreqs;
  CFreqs = removeEmpty(target=CFreqs, margin="rows");
  newrows = nrow(CFreqs);
  print("Old=" + oldrows + ", New=" + newrows);

  # copy rows from CMeans and CVars based on non-zero structure of CFreqs.
  if (oldrows != newrows) {
    print("copying cmneans and cvars");
    cmtemp = matrix(0, rows=newrows, cols=1);
    cvtemp = matrix(0, rows=newrows, cols=1);
    j=1;
    for(i in 1:oldrows) {
        if(castAsScalar(CFreqs_old[i,1]) > 0) {
            cmtemp[j,1] = CMeans[i,1];
            cvtemp[j,1] = CVars[i,1];
            j = j+1;
        }
    }
    CMeans = cmtemp;
    CVars  = cvtemp;
  } 

  # number of categories
  R = nrow(CFreqs);
  if (R == 1) {
      Eta = -1.0;
      AnovaF = -1.0;
      pVal = -1.0;
      df1 = -1.0;
      df2 = -1.0;
  }
  else {
      df1 = (R-1);
      df2 = (W-R);

      Eta = sqrt(1 - ( sum((CFreqs-1)*CVars) / ((W-1)*varY) ));

      anova_num = sum( (CFreqs*(CMeans-my)^2) )/(R-1);
      anova_den = sum( (CFreqs-1)*CVars )/(W-R);
      AnovaF = anova_num/anova_den;
      pVal = 1-cumulativeProbability(target=AnovaF, dist="F", df1=df1, df2=df2);
  }
}

# -----------------------------------------------------------------------------------------------------------
# Function to compute ranks
# takes a column vector as input, and produces a vector of same size in which each cell denotes to the computed score for that category

computeRanks = function(Matrix[Double] X) return (Matrix[Double] Ranks)
{
  Rks = X;
  size = nrow(X);
  for(i in 1:size)
  {
    prefixSum = 0.0;
    if (i > 1)
    {
      prefixSum = sum(X[1:(i-1), 1]);
    }
    Rks[i,1] = prefixSum + ((castAsScalar(X[i,1])+1)/2);
  }
  Ranks = Rks;
}

#-------------------------------------------------------------------------

bivar_oo = function(Matrix[Double] A, Matrix[Double] B) return (Double sp, Double gm, Double tau_a, Double tau_b, Double p_tau_b, Double tau_c, Double cnt)
{
  # compute contingency table
  F = table(A,B);

  nrF = nrow(F)
  ncF = ncol(F)

  if(nrF > 0 & ncF > 0){
    cnt = sum(F);

    # Compute Gamma
    [gm, tau_a, tau_b, p_tau_b, tau_c] = oo_gamma_tau(F);

    # Compute Spearman
    sp = oo_spearman(F);
  }else{
    gm = -2.0
    sp = -2.0
    tau_a = -2.0
    tau_b = -2.0
    tau_c = -2.0
    p_tau_b = -1.0
    cnt = 0.0    
  }
}

# -----------------------------------------------------------------------------------------------------------

oo_spearman = function(Matrix[Double] F) return (Double sp) {
  
  catA = nrow(F);  # number of categories in A
  catB = ncol(F);  # number of categories in B

  # compute category-wise counts for both the attributes
  R = rowSums(F);
  S = colSums(F);

    # compute scores, both are column vectors
  [C] = computeRanks(R);
  meanX = mean(C,R); 

  columnS = t(S);
  [D] = computeRanks(columnS);

    # scores (C,D) are individual values, and counts (R,S) act as weights
  meanY = mean(D,columnS);

  W = sum(F); # total weight, or total #cases
  varX = centralMoment(C,R,2)*(W/(W-1.0));
  varY = centralMoment(D,columnS,2)*(W/(W-1.0));

  covXY = 0.0;
  for(i in 1:catA)
  {
    covXY = covXY + sum((F[i,]/(W-1)) * (castAsScalar(C[i,1])-meanX) * (t(D[,1])-meanY));
  }
    
  sp = covXY/(sqrt(varX)*sqrt(varY));
}

# -----------------------------------------------------------------------------------------------------------

oo_gamma_tau = function(Matrix[Double] F) return (Double gm, Double tau_a, Double tau_b, Double p_tau_b, Double tau_c) 
{
    catA = nrow(F);
    catB = ncol(F);
    W = sum(F);
    
    num_agreements = 0.0;
    for( i in 1:(catA-1) ) {
        for( j in 1:(catB-1) ) {
            f_ij = castAsScalar(F[i,j]);
            temp_ij = F[(i+1):catA, (j+1):catB];
            sum_ij = sum(temp_ij);
            num_agreements = num_agreements + (f_ij * sum_ij);
            #print("f_ij = " + f_ij + ", sum_ij = " + sum_ij);
        }
    }
    #print("num_agreements = " + num_agreements);

    num_inversions = 0.0;
    for ( ii in 2:catA ) { # i from catA:2
        i = catA-ii+2;
	    for ( j in 1:(catB-1) ) {
	        f_ij = castAsScalar(F[i,j]);
            temp_ij = F[1:(i-1),(j+1):catB];
            sum_ij = sum(temp_ij);
            num_inversions = num_inversions + (f_ij * sum_ij); 
            #print("f_ij = " + f_ij + ", sum_ij = " + sum_ij);
	    }
    }
    #print("num_inversions = " + num_inversions);

    # ---------------
    # Gamma
    # ---------------
    gm = (num_agreements-num_inversions)/(num_agreements+num_inversions);
    
    #zscore = gm * sqrt( (num_agreements+num_inversions)/(W * (1-gm^2)) );
    #p_gm = 1-cumulativeProbability(target=zscore, dist="normal", mean=0, sd=1);
    #print("Gamma = [" + gm + ", " + zscore + ", " + p_gm + "]" );

    # ---------------
    # Kendall's Tau
    # ---------------
    num_pairs = (W*(W-1)/2);
    tau_a = (num_agreements - num_inversions)/num_pairs;
    #print("Tau-a = [" + tau_a + "]");

    R = rowSums(F);
    C = colSums(F);

    RR1 = R*(R-1);
    CC1 = C*(C-1);
    sRR1 = sum(RR1);
    sCC1 = sum(CC1);
    ties_A = sRR1/2;
    ties_B = sCC1/2;
    tau_b = (num_agreements - num_inversions)/sqrt(abs((num_pairs-ties_A)*(num_pairs-ties_B)));

    v0 = W*(W-1)*(2*W+5);
    vt = sum( RR1*(2*R+5) )
    vu = sum( CC1*(2*C+5) )
    v1 = (sRR1*sCC1) / (2*W*(W-1))
    v2 = (sum(RR1*(R-2)) * sum(CC1*(C-2))) / (9*W*(W-1)*(W-2))
    v = ((v0-vt-vu)/18) + v1 + v2
    z_tau_b = abs((num_agreements - num_inversions)/sqrt(abs(v)))
    p_tau_b = 2* (1-cumulativeProbability(target=z_tau_b, dist="normal", mean=0, sd=1));

    m = min(catA, catB); # smaller dimension
    tau_c = (num_agreements - num_inversions)*( (2*m) / (W^2*(m-1)) )

}
