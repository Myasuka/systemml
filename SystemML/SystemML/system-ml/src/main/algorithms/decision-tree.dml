#-------------------------------------------------------------
# IBM Confidential
# OCO Source Materials
# (C) Copyright IBM Corp. 2010, 2015
# The source code for this program is not published or
# otherwise divested of its trade secrets, irrespective of
# what has been deposited with the U.S. Copyright Office.
#-------------------------------------------------------------
#  
# THIS SCRIPT IMPLEMENTS CLASSIFICATION TREES (WITH SCALE FEATURES ONLY!)
#
# INPUT         PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME          TYPE     DEFAULT      MEANING
# ---------------------------------------------------------------------------------------------
# X             String   ---          Location to read feature matrix X; note that X needs to be recoded and dummy coded 
# Y 			String   ---		  Location to read label matrix Y
# T             String   " "          If X contains categorical features, location to read column matrix T denoting the types of the features in X: 
#									  0 for scale, 1 for categorical 
#									  If T is not provided all features are assumed to be scale
# bins          Int 	 20			  Number of equiheight bins per scale feature to choose thresholds
# depth         Int 	 25			  Maximum depth of the learnt tree
# num_leaf      Int      10           Number of samples when splitting stops and a leaf node is added
# num_samples   Int 	 3000		  Number of samples at which point we switch to in-memory subtree building
# impurity      String   "Gini"    	  Impurity measure: entropy (the default) or Gini 
# M             String 	 ---	   	  Location to write matrix M containing the learnt tree
# O     		String   " "          Location to write the training accuracy; by default is standard output
# fmt     	    String   "text"       The output format of the model (matrix M), such as "text" or "csv"
# ---------------------------------------------------------------------------------------------
# OUTPUT: 
# Matrix M where each column corresponds to a node in the learnt tree and each row contains the following information:
#	 M[1,j]: id of node j (in a complete binary tree)
#	 M[2,j]: Offset (no. of columns) to left child of j 
#	 M[3,j]: Feature index of the feature that node j looks at if j is an internal node, otherwise 0
#	 M[4,j]: Type of the feature that node j looks at if j is an internal node: 1 for scale and 2 for categorical features, 
#		     otherwise the label that leaf node j is supposed to predict
#	 M[5,j]: 1 if j is an internal node and the feature chosen for j is scale, otherwise the size of the subset of values 
#			 stored in rows 6,7,... if j is categorical
#	 M[6:,j]: Only applicable for internal nodes. Threshold the example's feature value is compared to is stored at M[6,j] if the feature chosen for j is scale;
# 			  If the feature chosen for j is categorical rows 6,7,... depict the value subset chosen for j   
# -------------------------------------------------------------------------------------------
# HOW TO INVOKE THIS SCRIPT - EXAMPLE:
# hadoop jar SystemML.jar -f decision-tree-scale.dml -nvargs X=INPUT_DIR/X Y=INPUT_DIR/Y I=INPUT_DIR/I T=INPUT_DIR/T M=OUTPUT_DIR/M
#     				                 					     bins=20 depth=20 num_leaf=1 num_samples=3000 impurity=entropy fmtO=csv


# udf for binning
binning = externalFunction(Matrix[Double] A, Integer binsize, Integer numbins) return (Matrix[Double] B, Integer numbinsdef) 
	implemented in (classname="com.ibm.bi.dml.udf.lib.BinningWrapper",exectype="mem")

	
# Default values of some parameters	
fileT = ifdef ($T, " ");	
fileO = ifdef ($O, " ");
fileM = $M;
num_bins = ifdef($bins, 20);  
depth = ifdef($depth, 25); 
num_leaf = ifdef($leaf, 10); 
threshold = ifdef ($num_samples, 3000);  
imp = ifdef($impurity, "Gini");
fmtO = ifdef($fmt, "text");

X = read($X)
Y = read($Y)

Y_bin = table (seq (1, num_rows), Y); # Y in binary representation
num_classes = ncol (Y_bin);
num_records = nrow (X);

if (fileT != " ") {
	T = read (fileT);
	T_min = min (T);
	T_max = max (T);
	if (T_min != 0 & T_max != 1) {
		stop ("Types must be 0 or 1!");
	} else {
		if (sum (T) != ncol (X)) { # both scale and categorical features exist
			col_ind_cat = removeEmpty (target = seq (1, ncol (X)) * T, margin = "rows");
			col_ind_scale = removeEmpty (targte = seq (1, ncol (X)) * (1 - T), margin = "rows");
			X_cat = X %*% table (col_ind_cat, seq (1, nrow (col_ind_cat)), ncol (X), nrow (col_ind_cat));
			X_scale = X %*% table (col_ind_scale, seq (1, nrow (col_ind_scale)), ncol (X), nrow (col_ind_scale));
			num_cat_features = ncol (X_cat);
			num_scale_features = ncol (X_scale);
		} else { # all features categorical
			X_cat = X;
			num_cat_features = ncol (X_cat);
			num_scale_features = 0;
		}
	}	
} else { # only scale features exist
	X_scale = X;
	num_scale_features = ncol (X_scale);
	num_cat_features = 0;
	distinct_values_max = 1;
}	

if (num_scale_features > 0) {

	print ("COMPUTING BINNING...");
	bin_size = max (as.integer (num_records / num_bins), 1);
	count_thresholds = matrix (0, rows = 1, cols = num_scale_features)
	thresholds = matrix (0, rows = num_bins + 1, cols = num_scale_features)
	parfor(i1 in 1:num_scale_features) { 
		col = order (target = X_scale[,i1], by = 1, decreasing = FALSE);
		[col_bins, num_bins_defined] = binning (col, bin_size, num_bins);
		count_thresholds[,i1] = num_bins_defined;
		thresholds[,i1] = col_bins;	
	}
	
	print ("PREPROCESSING SCALE FEATURE MATRIX...");
	min_num_bins = min (count_thresholds);
	max_num_bins = max (count_thresholds);
	total_num_bins = sum (count_thresholds);
	cum_count_thresholds = t (cumsum (t (count_thresholds)));
	# print ("min no. bins: " + (min_num_bins + 1) + " max no. bins: " + (max_num_bins + 1) + " total no. bins: " + (total_num_bins + num_scale_features));
	X_ext_left = matrix (0, rows = num_records, cols = total_num_bins);
	parfor (i2 in 1:num_scale_features, check = 0) { 
		Xi2 = X_scale[,i2];
		count_threshold = as.scalar (count_thresholds[,i2]);
		offset_feature = 1;
		if (i2 > 1) {
			offset_feature = offset_feature + as.integer (as.scalar (cum_count_thresholds[, (i2 - 1)]));
		}
		# print ("offset_feature " + offset_feature + " count_threshold " + count_threshold);
		ti2 = t(thresholds[1:count_threshold, i2]);
		X_ext_left[,offset_feature:(offset_feature + count_threshold - 1)] = outer (Xi2, ti2, "<");
	}
}

if (num_cat_features > 0) {
	distinct_values = colMaxs (X_cat);
	distinct_values_max = max (distinct_values);
	distinct_values_offset = cumsum (t (distinct_values));
	distinct_values_overall = sum (distinct_values);
}


##### INITIALIZATION
L = matrix (1, rows = num_rows, cols = 1); # last visited

# model
# leaf nodes
NC_large = matrix (0, rows = 3, cols = 1); # ids, class labels and no. of misclassified points at LARGE leaf nodes 
NC_small = matrix (0, rows = 3, cols = 1); # ids, class labels and no. of misclassified points at SMALL leaf nodes 

# internal nodes
Q_large = matrix (1, rows = 1, cols = 1); # ids of LARGE internal nodes 
Q_small = matrix (0, rows = 1, cols = 1); # ids of SMALL internal nodes

F_large = matrix (0, rows = 3, cols = 1); # features, types, offsets for LARGE internal nodes
F_small = matrix (0, rows = 3, cols = 1); # features, types, offsets SMALL internal nodes
S_large = matrix (0, rows = 1, cols = 1); # split points for LARGE internal nodes
S_small = matrix (0, rows = 1, cols = 1); # split points for SMALL internal nodes


# temp matrices 
cur_nodes_large = matrix (1, rows = 1, cols = 1);
# cur_nodes_small_nonzero = matrix (0, rows = 2, cols = 2); # first row: ids of SMALL internal nodes, second row: no. of samples for these nodes


num_cur_nodes_large = 1;
num_cur_nodes_small = 0;
level = 0;

while ((num_cur_nodes_large + num_cur_nodes_small) > 0 & level < depth) {
	
	level = level + 1;
	print (" --- start level " + level + " --- ");
	
	##### PREPARE MODEL
	if (num_cur_nodes_large > 0) { # LARGE nodes to process
		cur_Q_large = matrix (0, rows = 1, cols = 2 * num_cur_nodes_large);
		cur_NC_large = matrix (0, rows = 3, cols = 2 * num_cur_nodes_large); 
		cur_F_large = matrix (0, rows = 3, cols = num_cur_nodes_large); 
		cur_S_large = matrix (0, rows = 1, cols = num_cur_nodes_large * distinct_values_max); # split values of the best feature, worst case for cat. features
		cur_nodes_small = matrix (0, rows = 2, cols = num_cur_nodes_large); # cur_NC_large; 
	}

	##### LOOP OVER LARGE NODES...
	parfor (i6 in 1:num_cur_nodes_large, check = 0) { 
	
		cur_node = as.scalar (cur_nodes_large[,i6]);	
		print (" Expanding LARGE node: " + cur_node);
			
		# --- find best split ---
		# samples that reach cur_node 
		Ix = ppred (L[,1], cur_node, "==");		
		
		cur_Y_bin = Y_bin * Ix;
		label_counts_overall = colSums (cur_Y_bin);
		label_sum_overall = sum (label_counts_overall);
		label_dist_overall = label_counts_overall / label_sum_overall;

		if (imp == "entropy") {
			label_dist_zero = ppred (label_dist_overall, 0, "==");
			# cur_impurity = - sum (label_dist_overall * log (label_dist_overall + label_dist_zero) / log (2)); # impurity before
			cur_impurity = - sum (label_dist_overall * log (label_dist_overall + label_dist_zero)); # impurity before
		} else { # imp == "Gini"
			cur_impurity = sum (label_dist_overall * (1 - label_dist_overall)); # impurity before
		}
		best_scale_gain = 0;
		best_cat_gain = 0;
		if (num_scale_features > 0) {
			
			# main operation	
			label_counts_left_scale = t (t (cur_Y_bin) %*% X_ext_left); 
		
			# compute left and right label distribution
			label_sum_left = rowSums (label_counts_left_scale);
			label_dist_left = label_counts_left_scale / label_sum_left;
			if (imp == "entropy") {
				label_dist_left = replace (target = label_dist_left, pattern = 0, replacement = 1);
				log_label_dist_left = log (label_dist_left); # / log (2)
				impurity_left_scale = - rowSums (label_dist_left * log_label_dist_left); 
			} else { # imp == "Gini"
				impurity_left_scale = rowSums (label_dist_left * (1 - label_dist_left)); 
			}
			#
			label_counts_right_scale = - label_counts_left_scale + label_counts_overall; 
			label_sum_right = rowSums (label_counts_right_scale);
			label_dist_right = label_counts_right_scale / label_sum_right;
			if (imp == "entropy") {
				label_dist_right = replace (target = label_dist_right, pattern = 0, replacement = 1);
				log_label_dist_right = log (label_dist_right); # / log (2)
				impurity_right_scale = - rowSums (label_dist_right * log_label_dist_right); 		
			} else { # imp == "Gini"
				impurity_right_scale = rowSums (label_dist_right * (1 - label_dist_right)); 
			}
			
			I_gain_scale = cur_impurity - ( ( label_sum_left / label_sum_overall ) * impurity_left_scale + ( label_sum_right / label_sum_overall ) * impurity_right_scale); 
		
			I_gain_scale = replace (target = I_gain_scale, pattern = "NaN", replacement = 0);	
			
			# determine best feature to split on and the split value
			best_scale_gain = max (I_gain_scale);
			max_I_gain_ind_scale = as.scalar (rowIndexMax (t (I_gain_scale))); 
			p = ppred (cum_count_thresholds, max_I_gain_ind_scale, "<");
			sum_cum_count_thresholds = sum (p);
			best_scale_feature = sum_cum_count_thresholds + 1;
			best_scale_split = max_I_gain_ind_scale;
			if (best_scale_feature != 1) {
				best_scale_split = best_scale_split - as.scalar(cum_count_thresholds[,(best_scale_feature - 1)]);
			}				
		}
	
		if (num_cat_features > 0){
					
			# initialization
			split_values_bin = matrix (0, rows = 1, cols = distinct_values_overall); 
			split_values = split_values_bin; 
			split_values_offset = matrix (0, rows = 1, cols = num_cat_features); 
			I_gains = split_values_offset; 
			impurities_left = split_values_offset;
			impurities_right = split_values_offset;
			best_label_counts_left = matrix (0, rows = num_cat_features, cols = num_classes);
			best_label_counts_right = matrix (0, rows = num_cat_features, cols = num_classes);
		
			# main operation
			label_counts = t (t (cur_Y_bin) %*% X_ext);  
		
			parfor (i9 in 1:num_cat_features, check = 0){
			
				start_ind = 1;
				if (i9 > 1) {
					start_ind = start_ind + as.scalar (distinct_values_offset[(i9 - 1),]);
				}
				offset = as.scalar (distinct_values[1,i9]);
			
				cur_label_counts = label_counts[start_ind:(start_ind + offset - 1),];
			
				label_sum = rowSums (cur_label_counts);
				label_dist = cur_label_counts / label_sum;
				if (imp == "entropy") {
					label_dist = replace (target = label_dist, pattern = 0, replacement = 1);
					log_label_dist = log (label_dist); # / log(2)
					impurity = - rowSums (label_dist * log_label_dist); 
					impurity = replace (target = impurity, pattern = "NaN", replacement = 1/0); 
				} else { # imp == "Gini"
					impurity = rowSums (label_dist * (1 - label_dist)); 				
				}
			
				# sort cur feature by impurity
				cur_distinct_values = seq (1, nrow (cur_label_counts));
				cur_distinct_values_impurity = append (cur_distinct_values, impurity);
				cur_feature_sorted = order (target = cur_distinct_values_impurity, by = 2, decreasing = FALSE);
				P = table (cur_distinct_values, cur_feature_sorted); # permutation matrix
				label_counts_sorted = P %*% cur_label_counts;

				# compute left and right label distribution			
				label_counts_left = cumsum (label_counts_sorted);
			
				label_sum_left = rowSums (label_counts_left);
				label_dist_left = label_counts_left / label_sum_left;
				label_dist_left = replace (target = label_dist_left, pattern = "NaN", replacement = 1);
				if (imp == "entropy") {
					label_dist_left = replace (target = label_dist_left, pattern = 0, replacement = 1);
					log_label_dist_left = log (label_dist_left); # / log(2)
					impurity_left = - rowSums (label_dist_left * log_label_dist_left);
				} else { # imp == "Gini"
					impurity_left = rowSums (label_dist_left * (1 - label_dist_left));					
				}
				#
				label_counts_right = - label_counts_left + label_counts_overall;
				label_sum_right = rowSums (label_counts_right);
				label_dist_right = label_counts_right / label_sum_right;
				label_dist_right = replace (target = label_dist_right, pattern = "NaN", replacement = 1);
				if (imp == "entropy") {
					label_dist_right = replace (target = label_dist_right, pattern = 0, replacement = 1);
					log_label_dist_right = log (label_dist_right); # / log (2)
					impurity_right = - rowSums (label_dist_right * log_label_dist_right);			
				} else { # imp == "Gini"
					impurity_right = rowSums (label_dist_right * (1 - label_dist_right));					
				}
				I_gain = cur_impurity - ( ( label_sum_left / label_sum_overall ) * impurity_left + ( label_sum_right / label_sum_overall ) * impurity_right);
			
				Ix_label_sum_left_zero = ppred (label_sum_left, 0, "==");
				Ix_label_sum_right_zero = ppred (label_sum_right, 0, "==");
				Ix_label_sum_zero = Ix_label_sum_left_zero * Ix_label_sum_right_zero;
				I_gain = I_gain * (1 - Ix_label_sum_zero);	
				
				I_gain[nrow (I_gain),] = 0; # last entry invalid
			
				max_I_gain_ind = as.scalar (rowIndexMax (t (I_gain)));

				split_values[1, start_ind:(start_ind + max_I_gain_ind - 1)] = t (cur_feature_sorted[1:max_I_gain_ind,1]);
				for (i10 in 1:max_I_gain_ind) {
					ind = as.scalar (cur_feature_sorted[i10,1]);
					if (ind == 1) {
						split_values_bin[1,start_ind] = 1.0; 
					} else {
						split_values_bin[1,(start_ind + ind - 1)] = 1.0;
					}
				}
				split_values_offset[1,i9] = max_I_gain_ind;
			
				I_gains[1,i9] = max (I_gain);
			
				impurities_left[1,i9] = as.scalar (impurity_left[max_I_gain_ind,]);
				impurities_right[1,i9] = as.scalar (impurity_right[max_I_gain_ind,]);
				best_label_counts_left[i9,] = label_counts_left[max_I_gain_ind,];
				best_label_counts_right[i9,] = label_counts_right[max_I_gain_ind,];
			}
		
			# determine best feature to split on and the split values
			best_cat_feature = as.scalar (rowIndexMax (I_gains));
			best_cat_gain = max (I_gains);
			start_ind = 1;
			if (best_cat_feature > 1) {
				start_ind = start_ind + as.scalar (distinct_values_offset[(best_cat_feature - 1),]);
			}
			offset = as.scalar (distinct_values[1,best_cat_feature]);
			best_split_values_bin = split_values_bin[1, start_ind:(start_ind + offset - 1)];
												  
		}
		
		# print ("best_scale_gain " + best_scale_gain + " best_cat_gain " + best_cat_gain + " for large node " + cur_node);		
	
		# compare best scale feature to best cat. feature and pick the best one
		if (best_scale_gain >= best_cat_gain & best_scale_gain > 0) {
			
			# --- update model ---
			cur_F_large[1,i6] = best_scale_feature; 
			cur_F_large[2,i6] = 1;
			cur_F_large[3,i6] = 1;
			cur_S_large[1,(i6 - 1) * distinct_values_max + 1] = thresholds[best_scale_split, best_scale_feature]; 
				
			left_child = 2 * (cur_node - 1) + 1 + 1;
			right_child = 2 * (cur_node - 1) + 2 + 1;
					
			# samples going to the left subtree
			Ix_left = X_ext_left[, max_I_gain_ind_scale];
											
			Ix_left = Ix * Ix_left;		
			Ix_right = Ix * (1 - Ix_left);
				
			L[,1] = L[,1] * (1 - Ix_left) + (Ix_left * left_child);
			L[,1] = L[,1] * (1 - Ix_right) + (Ix_right * right_child);				
	
			left_child_size = sum (Ix_left);
			right_child_size = sum (Ix_right);
		
			# print ("parent " + cur_node + ": size(" + left_child + ") --> " + left_child_size + " size(" + right_child + ") --> " + right_child_size);
			# print ("best scale feature selected " + best_scale_feature);
			
			# check if left or right child is a leaf
			left_pure = FALSE;
			right_pure = FALSE;
			cur_impurity_left = as.scalar(impurity_left_scale[max_I_gain_ind_scale,]);
			cur_impurity_right = as.scalar(impurity_right_scale[max_I_gain_ind_scale,]);
			if ( (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) & (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) ) { # both left and right nodes are leaf	
				
				cur_label_counts_left = label_counts_left_scale[max_I_gain_ind_scale,];
				cur_NC_large[1,(2 * (i6 - 1) + 1)] = left_child; 
				cur_NC_large[2,(2 * (i6 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label
				left_pure = TRUE;	
				# compute number of misclassified points 
				cur_NC_large[3,(2 * (i6 - 1) + 1)] = left_child_size - max (cur_label_counts_left); 
				
				cur_label_counts_right = label_counts_overall - cur_label_counts_left;
				cur_NC_large[1,(2 * i6)] = right_child; 
				cur_NC_large[2,(2 * i6)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
				right_pure = TRUE;	
				# compute number of misclassified pints
				cur_NC_large[3,(2 * i6)] = right_child_size - max (cur_label_counts_right); 
				
			} else if (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) {
				
				cur_label_counts_left = label_counts_left_scale[max_I_gain_ind_scale,];
				cur_NC_large[1,(2 * (i6 - 1) + 1)] = left_child; 
				cur_NC_large[2,(2 * (i6 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label				
				left_pure = TRUE;
				# compute number of misclassified points 
				cur_NC_large[3,(2 * (i6 - 1) + 1)] = left_child_size - max (cur_label_counts_left);
				
			} else if (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) {
			
				cur_label_counts_right = label_counts_right_scale[max_I_gain_ind_scale,];
				cur_NC_large[1,(2 * i6)] = right_child; 
				cur_NC_large[2,(2 * i6)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
				right_pure = TRUE;
				# compute number of misclassified pints
				cur_NC_large[3,(2 * i6)] = right_child_size - max (cur_label_counts_right);
				
			}
		
		} else if (best_cat_feature > 0) {
			
			# --- update model ---
			cur_F_large[1,i6] = best_cat_feature; # best_feature;
			offset_nonzero = as.scalar (split_values_offset[1,best_cat_feature]);
			S_start_ind = (i6 - 1) * distinct_values_max + 1;
			cur_S_large[1,S_start_ind:(S_start_ind + offset_nonzero - 1)] = split_values[1,start_ind:(start_ind + offset_nonzero - 1)];
			cur_F_large[3,i6] = offset_nonzero; 
			cur_F_large[2,i6] = 2;
			
			# print ("best cat feature selected " + best_cat_feature + " size of subset " + offset_nonzero);		
		
			left_child = 2 * (cur_node - 1) + 1 + 1;
			right_child = 2 * (cur_node - 1) + 2 + 1;
					
			# samples going to the left subtree
			Ix_left = rowSums (X_ext[,start_ind:(start_ind + offset - 1)] * best_split_values_bin);
			Ix_left = ppred (Ix_left, 1, ">=");
											  
			Ix_left = Ix * Ix_left;		
			Ix_right = Ix * (1 - Ix_left);
				
			L[,1] = L[,1] * (1 - Ix_left) + (Ix_left * left_child);
			L[,1] = L[,1] * (1 - Ix_right) + (Ix_right * right_child);				
			
			left_child_size = sum (Ix_left);
			right_child_size = sum (Ix_right);
			
			# print ("parent " + cur_node + ": size(" + left_child + ") --> " + left_child_size + " size(" + right_child + ") --> " + right_child_size);
			
			# check if left or right child is a leaf
			left_pure = FALSE;
			right_pure = FALSE;
			cur_impurity_left = as.scalar(impurities_left[,best_cat_feature]); 
			cur_impurity_right = as.scalar(impurities_right[,best_cat_feature]); 
			if ( (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) & (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) ) { # both left and right nodes are leaf	
				
				cur_label_counts_left = best_label_counts_left[best_cat_feature,];
				cur_NC_large[1,(2 * (i6 - 1) + 1)] = left_child; 
				cur_NC_large[2,(2 * (i6 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label
				left_pure = TRUE;
				# compute number of misclassified points 
				cur_NC_large[3,(2 * (i6 - 1) + 1)] = left_child_size - max (cur_label_counts_left); 
				
				cur_label_counts_right = label_counts_overall - cur_label_counts_left;
				cur_NC_large[1,(2 * i6)] = right_child; 
				cur_NC_large[2,(2 * i6)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
				right_pure = TRUE;
				# compute number of misclassified pints
				cur_NC_large[3,(2 * i6)] = right_child_size - max (cur_label_counts_right);				
			
			} else if (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) {	
				
				cur_label_counts_left = best_label_counts_left[best_cat_feature,];
				cur_NC_large[1,(2 * (i6 - 1) + 1)] = left_child; 
				cur_NC_large[2,(2 * (i6 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label				
				left_pure = TRUE;
				# compute number of misclassified points 
				cur_NC_large[3,(2 * (i6 - 1) + 1)] = left_child_size - max (cur_label_counts_left);				
			
			} else if (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) {
				
				cur_label_counts_right = best_label_counts_right[best_cat_feature,];
				cur_NC_large[1,(2 * i6)] = right_child; 
				cur_NC_large[2,(2 * i6)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
				right_pure = TRUE;
				# compute number of misclassified pints
				cur_NC_large[3,(2 * i6)] = right_child_size - max (cur_label_counts_right);	
			
			}		
		}
		
		# add nodes to Q
		if (!left_pure) {
			if (left_child_size > threshold) {
				cur_Q_large[1,(2 * (i6 - 1)+ 1)] = left_child; 
			} else {
				cur_nodes_small[1,(2 * (i6 - 1)+ 1)] = left_child;
				cur_nodes_small[2,(2 * (i6 - 1)+ 1)] = left_child_size;
				print (left_child + " with size " + left_child_size + " added to cur_nodes_small");
			}
		}
		if (!right_pure) {
			if (right_child_size > threshold) {
				cur_Q_large[1,(2 * i6)] = right_child;
			} else{
				cur_nodes_small[1,(2 * i6)] = right_child;
				cur_nodes_small[2,(2 * i6)] = right_child_size;	
				print (right_child + " with size " + right_child_size + " added to cur_nodes_small");				
			}	
		}
	}
	
	##### PREPARE MODEL FOR LARGE NODES
	if (num_cur_nodes_large > 0) {
		cur_Q_large = removeEmpty (target = cur_Q_large, margin = "cols");
		if (as.scalar (cur_Q_large[1,1]) != 0) Q_large = append (Q_large, cur_Q_large);
		cur_NC_large = removeEmpty (target = cur_NC_large, margin = "cols");
		if (as.scalar (cur_NC_large[1,1]) != 0) NC_large = append (NC_large, cur_NC_large);
	
		F_large = append (F_large, cur_F_large);
		cur_S_large = removeEmpty (target = cur_S_large, margin = "cols");
		S_large = append (S_large, cur_S_large);	
			
		num_cur_nodes_large_pre = 2 * num_cur_nodes_large;
		if (as.scalar (cur_Q_large[1,1]) == 0) {
			num_cur_nodes_large = 0;
		} else {
			cur_nodes_large = cur_Q_large;
			num_cur_nodes_large = ncol (cur_Q_large);
		}	
	}

	##### PREPARE MODEL FOR SMALL NODES	
	cur_nodes_small_nonzero = removeEmpty (target = cur_nodes_small, margin = "cols");
	if (as.scalar (cur_nodes_small_nonzero[1,1]) != 0) { # if SMALL nodes exist
		num_cur_nodes_small = ncol (cur_nodes_small_nonzero);
	}
		
	if (num_cur_nodes_small > 0) { # SMALL nodes to process		
		reserve_len = sum (2 ^ (ceil (log (cur_nodes_small_nonzero[2,]) / log (2))));
		# print ("	reserve_len " + reserve_len + " for " + num_cur_nodes_small + " SMALL nodes");
		cur_Q_small =  matrix (0, rows = 1, cols = reserve_len);
		cur_NC_small = matrix (0, rows = 3, cols = reserve_len); 
		cur_F_small = matrix (0, rows = 3, cols = reserve_len); 
		cur_S_small = matrix (0, rows = 1, cols = reserve_len * distinct_values_max); # split values of the best feature	
	}

	##### LOOP OVER SMALL NODES...
	parfor (i7 in 1:num_cur_nodes_small, check = 0) { 
	
		cur_node_small = as.scalar (cur_nodes_small_nonzero[1,i7]);		
		# print ("Expanding SMALL node (root) " + cur_node_small);
		
		# build dataset for SMALL node
		Ix = ppred (L[,1], cur_node_small, "==");	
		if (num_scale_features > 0) {
			X_ext_left_small = removeEmpty (target = X_ext_left * Ix, margin = "rows");
		}
		if (num_cat_features > 0) {
			X_ext_small = removeEmpty (target = X_ext * Ix, margin = "rows");
		}
		L_small = removeEmpty (target = L * Ix, margin = "rows");
		Y_bin_small = removeEmpty (target = Y_bin * Ix, margin = "rows");
			
		# compute offset
		offsets = cumsum (t (2 ^ ceil (log (cur_nodes_small_nonzero[2,]) / log (2))));
		start_ind_global = 1;
		if (i7 > 1) {
			start_ind_global = start_ind_global + as.scalar (offsets[(i7 - 1),]);
		}
		end_ind = as.scalar (offsets[i7,]);
			
		Q = matrix (cur_node_small, rows = 1, cols = 1); 
		NC = matrix (0, rows = 3, cols = 1); 
		F = matrix (0, rows = 3, cols = 1); 
		S = matrix (0, rows = 1, cols = 1); 

		cur_nodes_ = matrix (cur_node_small, rows = 1, cols = 1);
		
		num_cur_nodes = 1;
		level_ = 0;
		while (num_cur_nodes > 0 & level_ < depth) {
			
			level_ = level_ + 1;
			cur_Q = matrix (0, rows = 1, cols = 2 * num_cur_nodes);
			cur_NC = matrix (0, rows = 3, cols = 2 * num_cur_nodes); 
			cur_F = matrix (0, rows = 3, cols = num_cur_nodes); 
			cur_S = matrix (0, rows = 1, cols = num_cur_nodes * distinct_values_max);
		
			parfor (i8 in 1:num_cur_nodes, check = 0) { 
			
				cur_node = as.scalar (cur_nodes_[,i8]);	
				# print ("    ---> Expanding SMALL node: " + cur_node);
				
				# --- find best split ---
				# samples that reach cur_node 
				Ix = ppred (L_small[,1], cur_node, "==");		
				cur_Y_bin = Y_bin_small * Ix;
				label_counts_overall = colSums (cur_Y_bin);
				
				label_sum_overall = sum (label_counts_overall);
				label_dist_overall = label_counts_overall / label_sum_overall;
				if (imp == "entropy") {
					label_dist_zero = ppred (label_dist_overall, 0, "==");
					cur_impurity = - sum (label_dist_overall * log (label_dist_overall + label_dist_zero)); 
				} else { # imp == "Gini"
					cur_impurity = sum (label_dist_overall * (1 - label_dist_overall)); 			
				}
				best_scale_gain = 0;
				best_cat_gain = 0;
				if (num_scale_features > 0) {
					
					# main operation	
					label_counts_left_scale = t (t (cur_Y_bin) %*% X_ext_left_small); 
		
					# compute left and right label distribution
					label_sum_left = rowSums (label_counts_left_scale);
					label_dist_left = label_counts_left_scale / label_sum_left;
					if (imp == "entropy") {
						label_dist_left = replace (target = label_dist_left, pattern = 0, replacement = 1);
						log_label_dist_left = log (label_dist_left); # / log (2)
						impurity_left_scale = - rowSums (label_dist_left * log_label_dist_left); 
					} else { # imp == "Gini"
						impurity_left_scale = rowSums (label_dist_left * (1 - label_dist_left)); 
					}
					#
					label_counts_right_scale = - label_counts_left_scale + label_counts_overall; 
					label_sum_right = rowSums (label_counts_right_scale);
					label_dist_right = label_counts_right_scale / label_sum_right;
					if (imp == "entropy") {
						label_dist_right = replace (target = label_dist_right, pattern = 0, replacement = 1);
						log_label_dist_right = log (label_dist_right); # log (2)
						impurity_right_scale = - rowSums (label_dist_right * log_label_dist_right); 		
					} else { # imp == "Gini"
						impurity_right_scale = rowSums (label_dist_right * (1 - label_dist_right)); 			
					}
					I_gain_scale = cur_impurity - ( ( label_sum_left / label_sum_overall ) * impurity_left_scale + ( label_sum_right / label_sum_overall ) * impurity_right_scale); # I_gain -> I_gain_scale
			
					I_gain_scale = replace (target = I_gain_scale, pattern = "NaN", replacement = 0);		
			
					# determine best feature to split on and the split value
					best_scale_gain = max (I_gain_scale);
					max_I_gain_ind_scale = as.scalar (rowIndexMax (t (I_gain_scale))); # max_I_gain_ind -> max_I_gain_ind_scale
					p = ppred (cum_count_thresholds, max_I_gain_ind_scale, "<");
					sum_cum_count_thresholds = sum (p);
					best_scale_feature = sum_cum_count_thresholds + 1;
					best_scale_split = max_I_gain_ind_scale;
					if (best_scale_feature != 1) {
						best_scale_split = best_scale_split - as.scalar(cum_count_thresholds[,(best_scale_feature - 1)]);
					}					
				}
				
				if (num_cat_features > 0){
														  
					# initialization
					split_values_bin = matrix (0, rows = 1, cols = distinct_values_overall); 
					split_values = split_values_bin; 
					split_values_offset = matrix (0, rows = 1, cols = num_cat_features); 
					I_gains = split_values_offset; 
					impurities_left = split_values_offset;
					impurities_right = split_values_offset;
					best_label_counts_left = matrix (0, rows = num_cat_features, cols = num_classes);
					best_label_counts_right = matrix (0, rows = num_cat_features, cols = num_classes);
		
					# main operation
					label_counts = t (t (cur_Y_bin) %*% X_ext_small); # X_ext_small 
		
					parfor (i9 in 1:num_cat_features, check = 0){
			
						start_ind = 1;
						if (i9 > 1) {
							start_ind = start_ind + as.scalar (distinct_values_offset[(i9 - 1),]);
						}
						offset = as.scalar (distinct_values[1,i9]);
			
						cur_label_counts = label_counts[start_ind:(start_ind + offset - 1),];
			
						label_sum = rowSums (cur_label_counts);
						label_dist = cur_label_counts / label_sum;
						if (imp == "entropy") {
							label_dist = replace (target = label_dist, pattern = 0, replacement = 1);
							log_label_dist = log (label_dist); # / log(2)
							impurity = - rowSums (label_dist * log_label_dist); 
							impurity = replace (target = impurity, pattern = "NaN", replacement = 1/0); 
						} else { # imp == "Gini"
							impurity = rowSums (label_dist * (1 - label_dist)); 
						}
						# sort cur feature by impurity
						cur_distinct_values = seq (1, nrow (cur_label_counts));
						cur_distinct_values_impurity = append (cur_distinct_values, impurity);
						cur_feature_sorted = order (target = cur_distinct_values_impurity, by = 2, decreasing = FALSE);
						P = table (cur_distinct_values, cur_feature_sorted); # permutation matrix
						label_counts_sorted = P %*% cur_label_counts;

						# compute left and right label distribution			
						label_counts_left = cumsum (label_counts_sorted);
			
						label_sum_left = rowSums (label_counts_left);
						label_dist_left = label_counts_left / label_sum_left;
						label_dist_left = replace (target = label_dist_left, pattern = "NaN", replacement = 1);
						if (imp == "entropy") {
							label_dist_left = replace (target = label_dist_left, pattern = 0, replacement = 1);
							log_label_dist_left = log (label_dist_left); # / log(2)
							impurity_left = - rowSums (label_dist_left * log_label_dist_left);
						} else { # imp == "Gini"
							impurity_left = rowSums (label_dist_left * (1 - label_dist_left));
						}
						#
						label_counts_right = - label_counts_left + label_counts_overall;
						label_sum_right = rowSums (label_counts_right);
						label_dist_right = label_counts_right / label_sum_right;
						label_dist_right = replace (target = label_dist_right, pattern = "NaN", replacement = 1);
						if (imp == "entropy") {
							label_dist_right = replace (target = label_dist_right, pattern = 0, replacement = 1);
							log_label_dist_right = log (label_dist_right); # / log (2)
							impurity_right = - rowSums (label_dist_right * log_label_dist_right);			
						} else { # imp == "Gini"
							impurity_right = rowSums (label_dist_right * (1 - label_dist_right));
						}
						I_gain = cur_impurity - ( ( label_sum_left / label_sum_overall ) * impurity_left + ( label_sum_right / label_sum_overall ) * impurity_right);
			
						Ix_label_sum_left_zero = ppred (label_sum_left, 0, "==");
						Ix_label_sum_right_zero = ppred (label_sum_right, 0, "==");
						Ix_label_sum_zero = Ix_label_sum_left_zero * Ix_label_sum_right_zero;
						I_gain = I_gain * (1 - Ix_label_sum_zero);	
			
						I_gain[nrow (I_gain),] = 0; # last entry invalid
			
						max_I_gain_ind = as.scalar (rowIndexMax (t (I_gain)));
			
						split_values[1, start_ind:(start_ind + max_I_gain_ind - 1)] = t (cur_feature_sorted[1:max_I_gain_ind,1]);
						for (i10 in 1:max_I_gain_ind) {
							ind = as.scalar (cur_feature_sorted[i10,1]);
							if (ind == 1) {
								split_values_bin[1,start_ind] = 1.0; 
							} else {
								split_values_bin[1,(start_ind + ind - 1)] = 1.0;
							}
						}
						split_values_offset[1,i9] = max_I_gain_ind;
			
						I_gains[1,i9] = max (I_gain);
			
						impurities_left[1,i9] = as.scalar (impurity_left[max_I_gain_ind,]);
						impurities_right[1,i9] = as.scalar (impurity_right[max_I_gain_ind,]);
						best_label_counts_left[i9,] = label_counts_left[max_I_gain_ind,];
						best_label_counts_right[i9,] = label_counts_right[max_I_gain_ind,];
					}
		
					# determine best feature to split on and the split values
					best_cat_feature = as.scalar (rowIndexMax (I_gains));
					best_cat_gain = max (I_gains);
					start_ind = 1;
					if (best_cat_feature > 1) {
						start_ind = start_ind + as.scalar (distinct_values_offset[(best_cat_feature - 1),]);
					}
					offset = as.scalar (distinct_values[1,best_cat_feature]);
					best_split_values_bin = split_values_bin[1, start_ind:(start_ind + offset - 1)];
				   
				}
				
				# print ("best_scale_gain " + best_scale_gain + " best_cat_gain " + best_cat_gain + " for small node " + cur_node);
				
				# compare best scale feature to best cat. feature and pick the best one
				if (best_scale_gain >= best_cat_gain & best_scale_gain > 0) {
					
					# --- update model ---
					cur_F[1,i8] = best_scale_feature; 
					cur_F[2,i8] = 1;
					cur_F[3,i8] = 1;
					cur_S[1,(i8 - 1) * distinct_values_max + 1] = thresholds[best_scale_split, best_scale_feature]; 
				
					left_child = 2 * (cur_node - 1) + 1 + 1;
					right_child = 2 * (cur_node - 1) + 2 + 1;
					
					# samples going to the left subtree
					Ix_left = X_ext_left_small[, max_I_gain_ind_scale];
														
					Ix_left = Ix * Ix_left;		
					Ix_right = Ix * (1 - Ix_left);
					
					L_small[,1] = L_small[,1] * (1 - Ix_left) + (Ix_left * left_child); 
					L_small[,1] = L_small[,1] * (1 - Ix_right) + (Ix_right * right_child);				
	
					left_child_size = sum (Ix_left);
					right_child_size = sum (Ix_right);
		
					# print ("parent " + cur_node + ": size(" + left_child + ") --> " + left_child_size + " size(" + right_child + ") --> " + right_child_size);
					# print ("best scale feature selected " + best_scale_feature);
				
					# check if left or right child is a leaf
					left_pure = FALSE;
					right_pure = FALSE;
					cur_impurity_left = as.scalar(impurity_left_scale[max_I_gain_ind_scale,]);
					cur_impurity_right = as.scalar(impurity_right_scale[max_I_gain_ind_scale,]);
					if ( (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) & (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) ) { # both left and right nodes are leaf	
						
						cur_label_counts_left = label_counts_left_scale[max_I_gain_ind_scale,];
						cur_NC[1,(2 * (i8 - 1) + 1)] = left_child; 
						cur_NC[2,(2 * (i8 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label
						left_pure = TRUE;	
						# compute number of misclassified points 
						cur_NC[3,(2 * (i8 - 1) + 1)] = left_child_size - max (cur_label_counts_left); 
				
						cur_label_counts_right = label_counts_overall - cur_label_counts_left;
						cur_NC[1,(2 * i8)] = right_child; 
						cur_NC[2,(2 * i8)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
						right_pure = TRUE;	
						# compute number of misclassified points 
						cur_NC[3,(2 * i8)] = right_child_size - max (cur_label_counts_right); 
						
					} else if (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) {
						
						cur_label_counts_left = label_counts_left_scale[max_I_gain_ind_scale,];
						cur_NC[1,(2 * (i8 - 1) + 1)] = left_child; 
						cur_NC[2,(2 * (i8 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label				
						left_pure = TRUE;	
						# compute number of misclassified points 
						cur_NC[3,(2 * (i8 - 1) + 1)] = left_child_size - max (cur_label_counts_left); 
						
					} else if (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) {
						
						cur_label_counts_right = label_counts_right_scale[max_I_gain_ind_scale,];
						cur_NC[1,(2 * i8)] = right_child; 
						cur_NC[2,(2 * i8)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
						right_pure = TRUE;
						# compute number of misclassified points 
						cur_NC[3,(2 * i8)] = right_child_size - max (cur_label_counts_right); 
						
					}									
														
				} else if (best_cat_gain > 0) {
					
					# --- update model ---
					cur_F[1,i8] = best_cat_feature; 
					offset_nonzero = as.scalar (split_values_offset[1,best_cat_feature]);
					S_start_ind = (i8 - 1) * distinct_values_max + 1;
					cur_S[1,S_start_ind:(S_start_ind + offset_nonzero - 1)] = split_values[1,start_ind:(start_ind + offset_nonzero - 1)];
					cur_F[3,i8] = offset_nonzero;
					cur_F[2,i8] = 2;

					# print ("best cat feature selected " + best_cat_feature + " size of subset " + offset_nonzero);
		
					left_child = 2 * (cur_node - 1) + 1 + 1;
					right_child = 2 * (cur_node - 1) + 2 + 1;
					
					# samples going to the left subtree
					Ix_left = rowSums (X_ext_small[,start_ind:(start_ind + offset - 1)] * best_split_values_bin);
					Ix_left = ppred (Ix_left, 1, ">=");
					
					Ix_left = Ix * Ix_left;		
					Ix_right = Ix * (1 - Ix_left);
				
					L_small[,1] = L_small[,1] * (1 - Ix_left) + (Ix_left * left_child); 
					L_small[,1] = L_small[,1] * (1 - Ix_right) + (Ix_right * right_child);				
			
					left_child_size = sum (Ix_left);
					right_child_size = sum (Ix_right);
			
					# print ("parent " + cur_node + ": size(" + left_child + ") --> " + left_child_size + " size(" + right_child + ") --> " + right_child_size);
		
					# check if left or right child is a leaf
					left_pure = FALSE;
					right_pure = FALSE;
					cur_impurity_left = as.scalar(impurities_left[,best_cat_feature]); 
					cur_impurity_right = as.scalar(impurities_right[,best_cat_feature]); 
					if ( (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) & (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) ) { # both left and right nodes are leaf	
						
						cur_label_counts_left = best_label_counts_left[best_cat_feature,];
						cur_NC[1,(2 * (i8 - 1) + 1)] = left_child; 
						cur_NC[2,(2 * (i8 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label
						left_pure = TRUE;
						# compute number of misclassified points 
						cur_NC[3,(2 * (i8 - 1) + 1)] = left_child_size - max (cur_label_counts_left); 
						
						cur_label_counts_right = label_counts_overall - cur_label_counts_left;
						cur_NC[1,(2 * i8)] = right_child; 
						cur_NC[2,(2 * i8)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
						right_pure = TRUE;
						# compute number of misclassified points 
						cur_NC[3,(2 * i8)] = right_child_size - max (cur_label_counts_right);
						
					} else if (left_child_size <= num_leaf | cur_impurity_left == 0 | (level == depth)) {	
					
						cur_label_counts_left = best_label_counts_left[best_cat_feature,];
						cur_NC[1,(2 * (i8 - 1) + 1)] = left_child; 
						cur_NC[2,(2 * (i8 - 1) + 1)] = as.scalar( rowIndexMax (cur_label_counts_left)); # leaf class label				
						left_pure = TRUE;
						# compute number of misclassified points 
						cur_NC[3,(2 * (i8 - 1) + 1)] = left_child_size - max (cur_label_counts_left);
						
					} else if (right_child_size <= num_leaf | cur_impurity_right == 0 | (level == depth)) {
					
						cur_label_counts_right = best_label_counts_right[best_cat_feature,];
						cur_NC[1,(2 * i8)] = right_child; 
						cur_NC[2,(2 * i8)] = as.scalar( rowIndexMax (cur_label_counts_right)); # leaf class label
						right_pure = TRUE;
						# compute number of misclassified points 
						cur_NC[3,(2 * i8)] = right_child_size - max (cur_label_counts_right);
						
					}		
				}
			
				# add nodes to Q
				if (!left_pure) {
					cur_Q[1,(2 * (i8 - 1)+ 1)] = left_child;
				}
				if (!right_pure) {
					cur_Q[1,(2 * i8)] = right_child;
				}
			}
		
			cur_Q = removeEmpty (target = cur_Q, margin = "cols");
			if (as.scalar (cur_Q[1,1]) != 0) Q = append (Q, cur_Q);
			cur_NC = removeEmpty (target = cur_NC, margin = "cols");
			if (as.scalar (cur_NC[1,1]) != 0) NC = append (NC, cur_NC);
	
			F = append (F, cur_F);
			cur_S = removeEmpty (target = cur_S, margin = "cols");
			S = append (S, cur_S);
		
			num_cur_nodes_pre = 2 * num_cur_nodes;
			if (as.scalar (cur_Q[1,1]) == 0) {
				num_cur_nodes = 0;
			} else {
				cur_nodes_ = cur_Q;
				num_cur_nodes = ncol (cur_Q);
			}
		}
		
		cur_Q_small[,start_ind_global:(start_ind_global + ncol (Q) - 1)] = Q;
		cur_NC_small[,start_ind_global:(start_ind_global + ncol (NC) - 1 - 1)] = NC[,2:ncol (NC)];
		cur_F_small[,start_ind_global:(start_ind_global + ncol (F) - 1 - 1)] = F[,2:ncol (F)];
		cur_S_small[,start_ind_global:(start_ind_global + ncol (S) - 1 - 1)] = S[,2:ncol (S)];		
	}

	##### PREPARE MODEL FOR SMALL NODES	
	if (num_cur_nodes_small > 0) {	# small nodes already processed
		cur_Q_small = removeEmpty (target = cur_Q_small, margin = "cols");
		Q_small = append (Q_small, cur_Q_small);
		cur_NC_small = removeEmpty (target = cur_NC_small, margin = "cols");
		NC_small = append (NC_small, cur_NC_small);
	
		cur_F_small = removeEmpty (target = cur_F_small, margin = "cols"); # 
		F_small = append (F_small, cur_F_small);
		cur_S_small = removeEmpty (target = cur_S_small, margin = "cols"); #		
		S_small = append (S_small, cur_S_small)

		num_cur_nodes_small = 0; # reset
	} 
		
	print (" --- end level " + level + ", remaining no. of LARGE nodes to expand " + num_cur_nodes_large + "  remaining no. of SMALL nodes to expand " + num_cur_nodes_small);
}

no_misclassified = sum (NC_large[3,]) + sum (NC_small[3,]);
accuracy = (1 - (no_misclassified / num_records)) * 100;
str_o = "no. of misclassified " + no_misclassified + " training accuracy " + accuracy + " %";
if (fileO != " ") {
	ACCURACY = matrix (accuracy, rows = 1, cols = 1);
	write (str_o, fileO, format = "text")
} else {
	print (str_o);
}


#### prepare model
# large nodes
if (as.scalar (Q_large[1,1]) == 0 & ncol (Q_large) > 1) {
	Q_large = Q_large[,2:ncol (Q_large)];
}
if (as.scalar (NC_large[1,1]) == 0 & ncol (NC_large) > 1) {
	NC_large = NC_large[,2:ncol (NC_large)];
}
if (as.scalar (S_large[1,1]) == 0 & ncol (S_large) > 1) {
	S_large = S_large[,2:ncol (S_large)];
}
if (as.scalar (F_large[1,1]) == 0 & ncol (F_large) > 1) {
	F_large = F_large[,2:ncol (F_large)];
}
# small nodes
if (as.scalar (Q_small[1,1]) == 0 & ncol (Q_small) > 1) {
	Q_small = Q_small[,2:ncol (Q_small)];
}
if (as.scalar (NC_small[1,1]) == 0 & ncol (NC_small) > 1) {
	NC_small = NC_small[,2:ncol (NC_small)];
}
if (as.scalar (S_small[1,1]) == 0 & ncol (S_small) > 1) {
	S_small = S_small[,2:ncol (S_small)];
}
if (as.scalar (F_small[1,1]) == 0 & ncol (F_small) > 1) {
	F_small = F_small[,2:ncol (F_small)];
}

# model corresponding to large internal nodes
no_large_internal_node = FALSE;
if (as.scalar (Q_large[1,1]) != 0) {
	num_large_internal = ncol (Q_large);
	max_offset = max (max (F_large[3,]), max (F_small[3,]));
	print ("max offset " + max_offset);
	M1_large = matrix (0, rows = 5 + max_offset, cols = num_large_internal);
	M1_large[1,] = Q_large;
	M1_large[3:5,] = F_large;
	# process S_large
	cum_offsets_large = cumsum (t (F_large[3,]));
	parfor (it in 1:num_large_internal, check = 0) {
		start_ind = 1;
		if (it > 1) {
			start_ind = start_ind + as.scalar (cum_offsets_large[(it - 1),]);
		}
		offset = as.scalar (F_large[3,it]);
		M1_large[6:(6 + offset - 1),it] = t (S_large[1,start_ind:(start_ind + offset - 1)]); 
	}	
} else {
	print ("No LARGE internal nodes available");
	no_large_internal_node = TRUE;
}

# model corresponding to small internal nodes
no_small_internal_node = FALSE;
if (as.scalar (Q_small[1,1]) != 0) {
	num_small_internal = ncol (Q_small);
	M1_small = matrix (0, rows = 5 + max_offset, cols = num_small_internal);
	M1_small[1,] = Q_small;
	M1_small[3:5,] = F_small;
	# process S_small
	cum_offsets_small = cumsum (t (F_small[3,]));
	parfor (it in 1:num_small_internal, check = 0) {
		start_ind = 1;
		if (it > 1) {
			start_ind = start_ind + as.scalar (cum_offsets_small[(it - 1),]);
		}
		offset = as.scalar (F_small[3,it]);
		M1_small[6:(6 + offset - 1),it] = t (S_small[1,start_ind:(start_ind + offset - 1)]); 
	}
} else {
	print ("No SMALL internal nodes available");	
	no_small_internal_node = TRUE;
}

# model corresponding to large leaf nodes
no_large_leaf_node = FALSE;
if (as.scalar (NC_large[1,1]) != 0) {
	num_large_leaf = ncol (NC_large);
	M2_large = matrix (0, rows = 5 + max_offset, cols = num_large_leaf);
	M2_large[1,] = NC_large[1,];
	M2_large[4,] = NC_large[2,];
	M2_large[5,] = NC_large[3,];
} else {
	print ("No LARGE leaf nodes available");
	no_large_leaf_node = TRUE;
}

# model corresponding to small leaf nodes
no_small_leaf_node = FALSE;
if (as.scalar (NC_small[1,1]) != 0) {
	num_small_leaf = ncol (NC_small);
	M2_small = matrix (0, rows = 5 + max_offset, cols = num_small_leaf);
	M2_small[1,] = NC_small[1,];
	M2_small[4,] = NC_small[2,];
	M2_small[5,] = NC_small[3,];
} else {
	print ("No SMALL leaf nodes available");
	no_small_leaf_node = TRUE;
}

if (no_large_internal_node) {
	M1 = M1_small;
} else if (no_small_internal_node) {
	M1 = M1_large;
} else {
	M1 = append (M1_large, M1_small);
}

if (no_large_leaf_node) {
	M2 = M2_small;
} else if (no_small_internal_node) {
	M2 = M2_large;
} else {
	M2 = append (M2_large, M2_small);
}

M = append (M1, M2);
M = t (order (target = t (M), by = 1));

if (!no_large_internal_node) {
	parfor (it in 1:ncol (Q_large), check = 0) {
		a1 = as.scalar (Q_large[1,it]);
		pos_a1 = sum (ppred (M[1,], a1, "<="));
		a2 = 2 * a1;
		pos_a2 = sum (ppred (M[1,], a2, "<="));
		M[2,pos_a1] = pos_a2 - pos_a1;
	}
}

if (!no_small_internal_node) {
	parfor (it2 in 1:ncol (Q_small), check = 0) {
		b1 = as.scalar (Q_small[1,it2]);
		pos_b1 = sum (ppred (M[1,], b1, "<="));
		b2 = 2 * b1;
		pos_b2 = sum (ppred (M[1,], b2, "<="));
		M[2,pos_b1] = pos_b2 - pos_b1;
	}
}

write (M, fileM, format = fmtO);


