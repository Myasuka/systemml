#-------------------------------------------------------------
# IBM Confidential
# OCO Source Materials
# (C) Copyright IBM Corp. 2010, 2015
# The source code for this program is not published or
# otherwise divested of its trade secrets, irrespective of
# what has been deposited with the U.S. Copyright Office.
#-------------------------------------------------------------
#  
# THIS SCRIPT COMPUTES LABEL PREDICTIONS MEANT FOR USE WITH A DECISION TREE MODEL ON A HELD OUT TEST SET.
#
# INPUT         PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME          TYPE     DEFAULT      MEANING
# ---------------------------------------------------------------------------------------------
# X             String   ---          Location to read test feature matrix X; note that X needs to be both recoded and dummy coded 
# P				String   ---		  Location to store the label predictions for X
# Y	 		    String   " "		  Location to read true label matrix Y if requested; note that Y needs to be both recoded and dummy coded
# R   	  		String   " "	      Location to read the matrix R which for each feature in X contains the following information 
#										- R[,1]: column ids
#										- R[,2]: start indices 
#										- R[,3]: end indices
#									  If R is not provided by default all variables are assumed to be scale
# M             String 	 ---	   	  Location to read matrix M containing the learnt tree i the following format
#										- M[1,j]: id of node j (in a complete binary tree)
#	 									- M[2,j]: Offset (no. of columns) to left child of j 
#	 									- M[3,j]: Feature index of the feature that node j looks at if j is an internal node, otherwise 0
#	 									- M[4,j]: Type of the feature that node j looks at if j is an internal node: 
#												  1 for scale and 2 for categorical features, otherwise the label that leaf node j is supposed to predict
#	 									- M[5,j]: 1 if j is an internal node and the feature chosen for j is scale, otherwise the size of the subset of values 
#			 									  stored in rows 6,7,... if j is categorical
#	 									- M[6:,j]: Only applicable for internal nodes. Threshold the example's feature value is compared to is stored at M[6,j] 
#												   if the feature chosen for j is scale; If the feature chosen for j is categorical rows 6,7,... 
#												   depict the value subset chosen for j
# accuracy     	String   " "          Location to write the test accuracy (%) for the prediction if requested
# confusion     String   " "		  Location to write the confusion matrix if requested 
# fmt     	    String   "text"       The output format of the output, such as "text" or "csv"
# ---------------------------------------------------------------------------------------------
# OUTPUT: 
#	1- Matrix Y containing the predicted labels for X 
#   2- Test accuracy if requested
#   3- Confusion matrix C if requested
# -------------------------------------------------------------------------------------------
# HOW TO INVOKE THIS SCRIPT - EXAMPLE:
# hadoop jar SystemML.jar -f decision-tree-scoring.dml -nvargs X=INPUT_DIR/X Y=INPUT_DIR/Y Y-test=INPUT_DIR/Y-test M=INPUT_DIR/M
#														accuracy=OUTPUT_DIR/accuracy confusion=OUTPUT_DIR/confusion fmtO=csv

fileX = $X;
fileP = $P;
fileY = ifdef ($Y, " ");
fileR = ifdef ($R, " ");
fileC = ifdef ($C, " ");
fileO = ifdef ($O, " ");
fmtO = ifdef ($fmt, "text");
X_test = read (fileX);

num_records = nrow (X_test);
Y_predicted = matrix (0, rows = num_records, cols = 1);

R_cat = matrix (0, rows = 1, cols = 1);
R_scale = matrix (0, rows = 1, cols = 1);

if (fileR != " ") {
	dummy_coded = ppred (R[,2], R[,3], "!=");
	R_scale = removeEmpty (target = R[,2] * (1 - dummy_coded), margin = "rows");
	R_cat = removeEmpty (target = R[,2:3] * dummy_coded, margin = "rows");
} else { # only scale features available
	R_scale = seq (1, ncol (X_test));
}

num_classified = 0;
for (i in 1:num_records) {
	cur_sample = X_test[i,];
	cur_node = 1;
	label_found = FALSE;
	while (!label_found) {
		cur_feature = as.scalar (M[3,cur_node]);	
		if (cur_feature == 0) { # leaf node
			label_found = TRUE;
			cur_label = as.scalar (M[4,cur_node]);
			Y_predicted[i,] = cur_label;
			num_classified = num_classified + 1;
		} else {
			# determine type: 1 for scale, 2 for categorical 
			cur_type = as.scalar (M[4,cur_node]);
			if (cur_type == 1) { # scale feature
				cur_start_ind = as.scalar (R_scale[cur_feature,]);
				cur_value = as.scalar (cur_sample[,cur_start_ind]);
				cur_split = as.scalar (M[6,cur_node]);
				if (cur_value < cur_split) { # go to left branch
					cur_node = cur_node + as.scalar (M[2,cur_node]);
				} else { # go to right branch
					cur_node = cur_node + as.scalar (M[2,cur_node]) + 1;
				}
			} else if (cur_type == 2) { # categorical feature				
				cur_start_ind = as.scalar (R_cat[cur_feature,1]);
				cur_end_ind = as.scalar (R_cat[cur_feature,2]);					
				cur_value = as.scalar (rowIndexMax(cur_sample[,cur_start_ind:cur_end_ind])); # as.scalar (cur_sample[,cur_feature]);
				cur_offset = as.scalar (M[5,cur_node]);
				value_found = sum (ppred (M[6:(6 + cur_offset - 1),cur_node], cur_value, "=="));
				print ("find " + cur_value);
				success = print_result (M[6:(6 + cur_offset - 1),cur_node]);
				if (value_found) { # go to left branch
					cur_node = cur_node + as.scalar (M[2,cur_node]);
				} else { # go to right branch
					cur_node = cur_node + as.scalar (M[2,cur_node]) + 1;
				}
			} 
		}
	}
}

write (Y_predicted, fileP, format = fmtO);

if (fileY != " ") {
	Y_test = read (fileY);
	num_classes = ncol (Y_test);
	Y_test = rowSums (Y_test * t (seq (1, num_classes)));
	result = ppred (Y_test, Y_predicted, "==");
	result = sum (result);
	accuracy = result / num_records * 100;
	acc_str = "Accuracy (%): " + accuracy;
	# print ("Test accuracy: " + accuracy + "%");
	if (fileO != " ") {
		write (acc_str, fileO);
	}
	if (fileC != " ") {
		CONFUSION_MAT = table(Y_predicted, Y_test, num_classes, num_classes)
        write(CONFUSION_MAT, fileC, format = fmtO)
	}
}
