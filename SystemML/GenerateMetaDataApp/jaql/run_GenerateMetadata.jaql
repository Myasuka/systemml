///////////////////////////////////////////////////////////////////////////////
// 
// IBM Confidential
// 
// OCO Source Materials
// 
// (C) Copyright IBM Corp. 2009, 2010, 2011, 2012
// 
// The source code for this program is not published or
// 
// otherwise divested of its trade secrets, irrespective of
// 
// what has been deposited with the U.S. Copyright Office.
// 
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// FILE run_GenerateMetadata.jaql
//
// DESCRIPTION: The jaql file that is called from oozie workflow.xml
///////////////////////////////////////////////////////////////////////////////

//
// Main Driver
//
/*

# Example of invoking this script from the Linux command line, using JSON as input:

IN_DIR=input
OUT_DIR=output
jaqlshell -jp custom_modules -e "
Input_input_PARAM          = \"$IN_DIR/data.json\";
Input_inputDelimiter_PARAM = \",\";
Input_inputMetadata_PARAM  = \"$IN_DIR/data.meta.json\";
Output_output_PARAM        = \"$OUT_DIR/data.json\";
" jaql/run_GenerateMetadata.jaql

# Example of invoking this script from the Linux command line, using JSON as input and no metadata:

IN_DIR=input
OUT_DIR=output
jaqlshell -jp custom_modules -e "
Input_input_PARAM          = \"$IN_DIR/data.json\";
Input_inputDelimiter_PARAM = \",\";
Input_inputMetadata_PARAM  = \" \";
Output_output_PARAM        = \"$OUT_DIR/data.json\";
" jaql/run_GenerateMetadata.jaql

# Example of invoking this script from the Linux command line, using CSV as input and no metadata:

IN_DIR=input
OUT_DIR=output
jaqlshell -jp custom_modules -e "
Input_input_PARAM          = \"$IN_DIR/data.csv\";
Input_inputDelimiter_PARAM = \",\";
Input_inputMetadata_PARAM  = \" \";
Output_output_PARAM        = \"$OUT_DIR/data.json\";
" jaql/run_GenerateMetadata.jaql

*/
//
//
// Main Flow:
//  
//    Initialize
//    If attributeKind is null, replace with heuristic
//    Generate recode map for categorical attributes
//

//
// --------------------------------------------------------------------------------
// Initialize
// --------------------------------------------------------------------------------
//



// DFS Path + filename for delimited or JSON text input data file
input = Input_input_PARAM;

// We determin the file format based on its suffix
inputFormat = if (endsWith(input, ".CSV") or endsWith(input, ".csv"))
(
   "CSV"
)
else if (endsWith(input, ".JSON") or endsWith(input, ".json"))
(
   "JSON Text Records"
);

// Input data delimiter. Used only when the user provides a CSV file. By default, we use comma as delimiter.
inputDelimiter = if (Input_inputDelimiter_PARAM != "")
(
   Input_inputDelimiter_PARAM
)
else
(
   ","
);


// DFS Path + filename for JSON text metadata input file. This is an optional input. 
// If the user provides one, it will help us to determine some attributes, such as attribute names, kind, etc.
// It will be merged into the output metadata file.
inputMetadata = Input_inputMetadata_PARAM;


//DFS Path + filename for JSON text output file.
output = if (endsWith(Output_output_PARAM, ".JSON") or endsWith(Output_output_PARAM , ".json"))
(
   Output_output_PARAM
)
else
(
   strcat(Output_output_PARAM, '.json')
);

// DFS Path + filename for the JSON text metadata output file generated by this script
outputMetadata = strcat(substring(output, 0, strLen(output) -5), '.meta.json');


"---------- BEGIN run_GenerateMetadata.jaql ---------";
import GenerateMetadata;

setOptions( { conf: { "mapred.reduce.tasks.speculative.execution" : false } });
setOptions( { conf: { "mapred.child.java.opts" : "-Xmx2000M" } });

// pin metadata in memory
metadataMem := if (inputMetadata != "") (if (ls(inputMetadata) == [])
(
   []
)
else
(
   read(jsonText(inputMetadata))
))
else
(
  []
);

jsonLines = fn(location)
    lines ( location,
        inoptions = { converter: "com.ibm.jaql.io.hadoop.converter.FromJsonTextConverter"},
        outoptions = { converter: "com.ibm.jaql.io.hadoop.converter.ToJsonTextConverter"});

// If the input is a CSV file, we need to convert it to a JSON file.
// We need to generate columnId for the input at this step, it will be later written into the metadata file.

inputData = if (inputFormat == "JSON Text Records")
(
   inputData = read(jsonLines(input))
);

metaAttributes = if (inputFormat == "CSV")
(
  GenerateMetadata::getInput(input, metadataMem)
)
else if (inputFormat == "JSON Text Records")
(
  GenerateMetadata::genJsonColumnMeta(inputData, metadataMem)
);


// --------------------------------------------------------------------------------
// Generate an metadata file with partial information. Because the user might use filter/project
// app in the next step, so we do not collect column distinct values at this step
// --------------------------------------------------------------------------------

GenerateMetadata::genMeta(metaAttributes, metadataMem, outputMetadata);   		   	  					   	

// We convert the CSV input file into a JSON format data file
// For JSON format input data file, if the user specifies to output to a different
// file name, we will make a copy  
if (inputFormat == "CSV")
(
	GenerateMetadata::writeCSVToJson(input, inputDelimiter, metaAttributes, output)
)
else if (inputFormat == "JSON Text Records" and output != input)
(
    inputData-> write(jsonLines(output))   

);

"---------- END run_GenerateMetadata.jaql -----------";
